<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Silly Paintings Painting World! - Digital Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    /* Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="paint-dots" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23paint-dots)"/></svg>');
      opacity: 0.3;
      pointer-events: none;
    }

    /* Header - Made larger and more colorful */
    .header {
      background: linear-gradient(90deg, rgba(255, 107, 157, 0.9), rgba(78, 205, 196, 0.9));
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(15px);
      border-bottom: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .logo {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo::before {
      content: 'üé®';
      font-size: 36px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .header-actions {
      display: flex;
      gap: 15px;
    }

    .header-btn {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      padding: 12px 20px;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      min-width: 100px;
    }

    .header-btn:hover {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    /* Main Layout - Maximized canvas area */
    .main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Left Sidebar - Bigger tools */
    .left-sidebar {
      width: 120px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), rgba(50, 50, 100, 0.6));
      backdrop-filter: blur(15px);
      border-right: 3px solid rgba(255, 255, 255, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 25px 15px;
      gap: 20px;
      box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
    }

    .tool-btn {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      color: white;
      font-size: 32px;
      cursor: pointer;
      transition: all 0.4s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .tool-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.6s;
    }

    .tool-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.2));
      transform: scale(1.1) rotate(5deg);
      border-color: #4ecdc4;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .tool-btn:hover::before {
      left: 100%;
    }

    .tool-btn.active {
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      border-color: #fff;
      box-shadow: 0 0 30px rgba(255, 107, 157, 0.8);
      transform: scale(1.05);
    }

    /* Canvas Area - Maximized */
    .canvas-area {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at center, #f8f9fa 0%, #e9ecef 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
    }

    #canvas-container {
      position: relative;
      background: linear-gradient(45deg, #ffffff, #f8f9ff);
      border-radius: 20px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      overflow: hidden;
      width: calc(100% - 30px);
      height: calc(100% - 30px);
      max-width: none;
      max-height: none;
      cursor: crosshair;
      border: 4px solid rgba(255, 255, 255, 0.8);
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      touch-action: none;
    }

    /* Right Sidebar - Enhanced visibility */
    .right-sidebar {
      width: 340px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), rgba(100, 50, 150, 0.6));
      backdrop-filter: blur(15px);
      border-left: 3px solid rgba(255, 255, 255, 0.2);
      padding: 25px;
      overflow-y: auto;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
    }

    .sidebar-section {
      margin-bottom: 35px;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .sidebar-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 20px;
      color: #4ecdc4;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      text-align: center;
    }

    /* Color Picker Section - Bigger colors */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .color-btn {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .color-btn:hover {
      transform: scale(1.2) rotate(10deg);
      border-color: #fff;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
    }

    .color-btn.active {
      border-color: #4ecdc4;
      border-width: 5px;
      box-shadow: 0 0 25px rgba(78, 205, 196, 0.8);
      transform: scale(1.1);
    }

    #colorPicker {
      width: 100%;
      height: 60px;
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 15px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    /* Brush Settings - Enhanced sliders */
    .slider-container {
      margin-bottom: 25px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .slider {
      width: 100%;
      height: 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(78, 205, 196, 0.3));
      outline: none;
      -webkit-appearance: none;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      border: 3px solid white;
    }

    .slider::-moz-range-thumb {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced Tiny Brush Controls */
    .tiny-brush-section {
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.3), rgba(78, 205, 196, 0.2));
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .tiny-brush-title {
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      text-align: center;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .tiny-brush-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .tiny-brush-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      padding: 10px 5px;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .tiny-brush-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: scale(1.05);
      border-color: #4ecdc4;
    }

    .tiny-brush-btn.active {
      border-color: #ff6b9d;
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.6), rgba(78, 205, 196, 0.4));
      box-shadow: 0 0 15px rgba(255, 107, 157, 0.5);
    }

    /* Brush controls - Better visibility */
    .brush-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .brush-type-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      color: white;
      cursor: pointer;
      padding: 15px 8px;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .brush-type-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.2));
      transform: scale(1.05);
      border-color: #4ecdc4;
    }

    .brush-type-btn.active {
      border-color: #ff6b9d;
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.5), rgba(78, 205, 196, 0.3));
      box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);
    }

    /* Layer Panel - Enhanced */
    .layers-panel {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      padding: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .layer-item {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid rgba(255, 255, 255, 0.2);
      font-weight: 600;
      font-size: 16px;
    }

    .layer-item:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
      transform: translateX(5px);
      border-color: #4ecdc4;
    }

    .layer-item.active {
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      box-shadow: 0 0 25px rgba(255, 107, 157, 0.5);
      border-color: #fff;
    }

    .layer-controls {
      display: flex;
      gap: 8px;
    }

    .layer-control-btn {
      background: rgba(255, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.5);
      width: 35px;
      height: 35px;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    .layer-control-btn:hover {
      background: rgba(255, 255, 255, 0.6);
      transform: scale(1.1);
      border-color: #4ecdc4;
    }

    /* Enhanced Brush Preview with size display */
    .brush-preview {
      width: 100%;
      height: 80px;
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      border-radius: 15px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      border: 3px solid rgba(255, 255, 255, 0.5);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .brush-stroke {
      border-radius: 50%;
      background: #333;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .size-display {
      position: absolute;
      bottom: 5px;
      right: 10px;
      font-size: 12px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.6);
      background: rgba(255, 255, 255, 0.8);
      padding: 2px 8px;
      border-radius: 8px;
    }

    /* Enhanced pressure indicator */
    .pressure-indicator {
      width: 100%;
      height: 25px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      margin-bottom: 15px;
      position: relative;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .pressure-bar {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #ff6b9d, #ffa500);
      border-radius: 13px;
      transition: width 0.3s ease;
      width: 50%;
      box-shadow: 0 0 15px rgba(255, 107, 157, 0.5);
    }

    /* Bottom Toolbar - Enhanced zoom controls */
    .bottom-toolbar {
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.7), rgba(50, 50, 100, 0.7));
      backdrop-filter: blur(15px);
      padding: 20px 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 30px;
      border-top: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 25px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .zoom-btn {
      background: linear-gradient(135deg, #4ecdc4, #45b7d1);
      border: 2px solid white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      font-size: 24px;
      font-weight: bold;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .zoom-btn:hover {
      transform: scale(1.15);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
    }

    .zoom-level {
      min-width: 80px;
      text-align: center;
      font-weight: 700;
      font-size: 18px;
      color: #4ecdc4;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced action buttons */
    .action-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      padding: 12px 18px;
      border-radius: 20px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .action-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .action-btn.undo {
      background: linear-gradient(135deg, #ffa500, #ff8c00);
    }

    .action-btn.redo {
      background: linear-gradient(135deg, #32cd32, #228b22);
    }

    .action-btn.clear {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
    }

    /* Tool cursors */
    .fill-cursor {
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="white" stroke="black" stroke-width="2" d="M16 8l8 8-8 8-8-8z"/></svg>'), auto !important;
    }

    .eraser-cursor {
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><rect x="4" y="10" width="20" height="12" rx="3" fill="pink" stroke="black" stroke-width="2"/></svg>'), auto !important;
    }

    /* Tool size indicator - Enhanced */
    .size-indicator {
      position: fixed;
      pointer-events: none;
      border: 3px solid #ff6b9d;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 107, 157, 0.2), rgba(78, 205, 196, 0.1));
      z-index: 1000;
      display: none;
      box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);
      min-width: 2px;
      min-height: 2px;
    }

    /* Loading animation - More colorful */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
      font-size: 24px;
      font-weight: 600;
    }

    .loading-spinner {
      width: 80px;
      height: 80px;
      border: 6px solid rgba(255, 255, 255, 0.3);
      border-top: 6px solid #ff6b9d;
      border-right: 6px solid #4ecdc4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 30px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* File input styling */
    .file-input {
      display: none;
    }

    /* Mobile responsiveness - Improved */
    @media (max-width: 1024px) {
      .right-sidebar {
        width: 300px;
      }
      
      .tool-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .left-sidebar {
        width: 100px;
      }
    }

    @media (max-width: 768px) {
      .header {
        padding: 15px 20px;
      }
      
      .logo {
        font-size: 24px;
      }
      
      .header-btn {
        padding: 10px 15px;
        font-size: 14px;
        min-width: 80px;
      }
      
      .main-container {
        flex-direction: column;
      }
      
      .left-sidebar {
        width: 100%;
        height: 100px;
        flex-direction: row;
        padding: 15px 20px;
        overflow-x: auto;
        gap: 15px;
      }
      
      .tool-btn {
        min-width: 70px;
        height: 70px;
        font-size: 24px;
      }
      
      .right-sidebar {
        width: 100%;
        height: 250px;
        overflow-y: auto;
      }
      
      .bottom-toolbar {
        padding: 15px 20px;
        gap: 20px;
      }
    }

    /* Tooltip styles */
    .tool-btn::after {
      content: attr(title);
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }

    .tool-btn:hover::after {
      opacity: 1;
    }

    /* Add some visual flair */
    .sidebar-section:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced canvas container with animated border */
    #canvas-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #ff6b9d, #4ecdc4, #45b7d1, #ff6b9d);
      border-radius: 22px;
      z-index: -1;
      animation: borderGlow 3s linear infinite;
      background-size: 200% 200%;
    }

    @keyframes borderGlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
  </style>
</head>
<body>
  <div class="loading" id="loadingScreen">
    <div class="loading-spinner"></div>
    <div>Loading Silly Paintings Painting World...</div>
    <div style="font-size: 16px; margin-top: 15px; opacity: 0.8;">Get ready to create something silly and beautiful! ‚ú®</div>
  </div>

  <div class="header">
    <div class="logo">Silly Paintings Painting World!</div>
    <div class="header-actions">
      <button class="header-btn" onclick="newProject()">üÜï New Canvas</button>
      <button class="header-btn" onclick="saveProject()">üíæ Save Art</button>
      <button class="header-btn" onclick="loadProject()">üìÇ Load Art</button>
      <button class="header-btn" onclick="exportPNG()">üì∑ Download</button>
    </div>
  </div>

  <div class="main-container">
    <div class="left-sidebar">
      <button class="tool-btn active" onclick="setTool('brush')" title="Brush Tool" id="brush-tool">
        üñåÔ∏è
      </button>
      <button class="tool-btn" onclick="setTool('paintbrush')" title="Paint Brush" id="paintbrush-tool">
        üé®
      </button>
      <button class="tool-btn" onclick="setTool('pencil')" title="Pencil Tool" id="pencil-tool">
        ‚úèÔ∏è
      </button>
      <button class="tool-btn" onclick="setTool('eraser')" title="Eraser Tool" id="eraser-tool">
        üßπ
      </button>
      <button class="tool-btn" onclick="setTool('fill')" title="Fill Bucket" id="fill-tool">
        ü™£
      </button>
      <button class="tool-btn" onclick="setTool('spray')" title="Spray Paint" id="spray-tool">
        üí®
      </button>
      <button class="tool-btn" onclick="setTool('marker')" title="Marker Tool" id="marker-tool">
        üñçÔ∏è
      </button>
      <button class="tool-btn" onclick="setTool('smudge')" title="Smudge Tool" id="smudge-tool">
        üëÜ
      </button>
    </div>

    <div class="canvas-area">
      <div id="canvas-container"></div>
      <div class="size-indicator" id="sizeIndicator"></div>
    </div>

    <div class="right-sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">üåà Colors</div>
        <div class="color-grid">
          <div class="color-btn active" style="background: #000;" onclick="selectColor('#000000')" title="Black"></div>
          <div class="color-btn" style="background: #fff;" onclick="selectColor('#ffffff')" title="White"></div>
          <div class="color-btn" style="background: #ff0000;" onclick="selectColor('#ff0000')" title="Red"></div>
          <div class="color-btn" style="background: #00ff00;" onclick="selectColor('#00ff00')" title="Green"></div>
          <div class="color-btn" style="background: #0000ff;" onclick="selectColor('#0000ff')" title="Blue"></div>
          <div class="color-btn" style="background: #ffff00;" onclick="selectColor('#ffff00')" title="Yellow"></div>
          <div class="color-btn" style="background: #ff00ff;" onclick="selectColor('#ff00ff')" title="Magenta"></div>
          <div class="color-btn" style="background: #00ffff;" onclick="selectColor('#00ffff')" title="Cyan"></div>
          <div class="color-btn" style="background: #ffa500;" onclick="selectColor('#ffa500')" title="Orange"></div>
          <div class="color-btn" style="background: #800080;" onclick="selectColor('#800080')" title="Purple"></div>
          <div class="color-btn" style="background: #ffc0cb;" onclick="selectColor('#ffc0cb')" title="Pink"></div>
          <div class="color-btn" style="background: #90ee90;" onclick="selectColor('#90ee90')" title="Light Green"></div>
        </div>
        <input type="color" id="colorPicker" value="#000000" onchange="selectColor(this.value)">
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">üñåÔ∏è Brush Settings</div>
        <div class="brush-preview">
          <div class="brush-stroke" id="brushPreview"></div>
          <div class="size-display" id="sizeDisplay">15px</div>
        </div>
        
        <!-- New Tiny Brush Section -->
        <div class="tiny-brush-section">
          <div class="tiny-brush-title">üî¨ Tiny Brushes</div>
          <div class="tiny-brush-grid">
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.1)" id="tiny-01">0.1px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.2)" id="tiny-02">0.2px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.3)" id="tiny-03">0.3px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.5)" id="tiny-05">0.5px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.7)" id="tiny-07">0.7px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.8)" id="tiny-08">0.8px</button>
          </div>
        </div>
        
        <div class="brush-controls">
          <button class="brush-type-btn active" onclick="setBrushType('normal')" id="normal-brush">Normal</button>
          <button class="brush-type-btn" onclick="setBrushType('texture')" id="texture-brush">Textured</button>
          <button class="brush-type-btn" onclick="setBrushType('soft')" id="soft-brush">Soft</button>
          <button class="brush-type-btn" onclick="setBrushType('hard')" id="hard-brush">Hard</button>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>üìè Size</span>
            <span id="sizeValue">15</span>
          </div>
          <input type="range" class="slider" id="brushSize" min="0.1" max="200" step="0.1" value="15" oninput="updateBrushSize(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>üíß Opacity</span>
            <span id="opacityValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushOpacity" min="1" max="100" value="100" oninput="updateOpacity(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>üåä Flow</span>
            <span id="flowValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushFlow" min="1" max="100" value="100" oninput="updateFlow(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>‚ö° Hardness</span>
            <span id="hardnessValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushHardness" min="0" max="100" value="100" oninput="updateHardness(this.value)">
        </div>
        
        <div class="pressure-indicator" title="Brush Pressure">
          <div class="pressure-bar" id="pressureBar"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">üìö Drawing Layers</div>
        <div class="layers-panel" id="layersPanel">
        </div>
        <button class="header-btn" onclick="addLayer()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #4ecdc4, #45b7d1);">‚ûï Add New Layer</button>
      </div>
    </div>
  </div>

  <div class="bottom-toolbar">
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
      <div class="zoom-level" id="zoomLevel">100%</div>
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    </div>
    <button class="action-btn undo" onclick="undoAction()" title="Undo Last Action">‚Ü∂ Undo</button>
    <button class="action-btn redo" onclick="redoAction()" title="Redo Last Action">‚Ü∑ Redo</button>
    <button class="action-btn clear" onclick="clearCurrentLayer()" title="Clear Current Layer">üßº Clear Layer</button>
  </div>

  <input type="file" id="fileInput" class="file-input" accept=".json" onchange="handleFileLoad(event)">

  <script>
    // Global variables
    let canvases = [];
    let currentLayerIndex = 0;
    let currentTool = 'brush';
    let currentBrushType = 'normal';
    let currentColor = '#000000';
    let currentSize = 15;
    let currentOpacity = 1.0;
    let currentFlow = 1.0;
    let currentHardness = 1.0;
    let zoomLevel = 1.0;
    let isDrawing = false;
    let undoStack = [];
    let redoStack = [];
    let pressureSimulation = 0.5;
    let isMouseDown = false;
    let isTinyBrushActive = false;
    
    // Canvas settings - Maximized for students
    const CANVAS_WIDTH = 1400;
    const CANVAS_HEIGHT = 900;
    const MAX_LAYERS = 10;

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        initializeApp();
        document.getElementById('loadingScreen').style.display = 'none';
      }, 2000);
    });

    function initializeApp() {
      createInitialLayers();
      setupCanvasContainer();
      updateLayersPanel();
      updateBrushPreview();
      setupEventListeners();
      showWelcomeMessage();
    }

    function showWelcomeMessage() {
      setTimeout(() => {
        alert('üé® Welcome to Silly Paintings Painting World! üé®\n\n‚ú® Tips for amazing silly art:\n‚Ä¢ Use [/] keys to change brush size quickly\n‚Ä¢ Try the new TINY brushes for super detailed work!\n‚Ä¢ Use different brush types for cool effects\n‚Ä¢ Use layers to organize your silly artwork\n‚Ä¢ Don\'t forget to save your masterpiece!\n\nHappy silly painting! üåà');
      }, 1000);
    }

    function setupEventListeners() {
      // Window resize handler
      window.addEventListener('resize', () => {
        canvases.forEach(canvas => {
          resizeCanvas(canvas);
        });
      });

      // Mouse move for size indicator
      document.addEventListener('mousemove', updateSizeIndicator);

      // Enhanced keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 'z':
              e.preventDefault();
              if (e.shiftKey) {
                redoAction();
              } else {
                undoAction();
              }
              break;
            case 'n':
              e.preventDefault();
              newProject();
              break;
            case 's':
              e.preventDefault();
              saveProject();
              break;
            case '=':
            case '+':
              e.preventDefault();
              zoomIn();
              break;
            case '-':
              e.preventDefault();
              zoomOut();
              break;
          }
        }
        
        // Tool shortcuts
        switch (e.key) {
          case 'b':
            setTool('brush');
            break;
          case 'p':
            if (!e.ctrlKey && !e.metaKey) setTool('paintbrush');
            break;
          case 'e':
            if (!e.ctrlKey && !e.metaKey) setTool('eraser');
            break;
          case 'f':
            setTool('fill');
            break;
          case 's':
            if (!e.ctrlKey && !e.metaKey) setTool('spray');
            break;
          case 'm':
            setTool('marker');
            break;
          case '1':
          case '2':
          case '3':
          case '4':
            const brushTypes = ['normal', 'texture', 'soft', 'hard'];
            const brushType = brushTypes[parseInt(e.key) - 1];
            if (brushType) setBrushType(brushType);
            break;
          case '[':
            // Decrease brush size (enhanced for tiny sizes)
            e.preventDefault();
            let newSizeDown;
            if (currentSize <= 1) {
              newSizeDown = Math.max(0.1, currentSize - 0.1);
            } else if (currentSize <= 5) {
              newSizeDown = Math.max(0.1, currentSize - 0.5);
            } else {
              newSizeDown = Math.max(0.1, currentSize - 5);
            }
            updateBrushSize(newSizeDown);
            document.getElementById('brushSize').value = newSizeDown;
            break;
          case ']':
            // Increase brush size (enhanced for tiny sizes)
            e.preventDefault();
            let newSizeUp;
            if (currentSize < 1) {
              newSizeUp = Math.min(200, currentSize + 0.1);
            } else if (currentSize < 5) {
              newSizeUp = Math.min(200, currentSize + 0.5);
            } else {
              newSizeUp = Math.min(200, currentSize + 5);
            }
            updateBrushSize(newSizeUp);
            document.getElementById('brushSize').value = newSizeUp;
            break;
          case 'Delete':
          case 'Backspace':
            if (e.ctrlKey) {
              e.preventDefault();
              clearCurrentLayer();
            }
            break;
        }
      });
    }

    function updateSizeIndicator(e) {
      const indicator = document.getElementById('sizeIndicator');
      const canvasContainer = document.getElementById('canvas-container');
      const containerRect = canvasContainer.getBoundingClientRect();
      
      // Only show indicator when hovering over canvas
      if (e.clientX >= containerRect.left && e.clientX <= containerRect.right &&
          e.clientY >= containerRect.top && e.clientY <= containerRect.bottom) {
        
        if (currentTool === 'brush' || currentTool === 'paintbrush' || 
            currentTool === 'pencil' || currentTool === 'eraser' || 
            currentTool === 'spray' || currentTool === 'marker') {
          
          // Enhanced size calculation for tiny brushes
          let displaySize = currentSize * (containerRect.width / CANVAS_WIDTH) * zoomLevel;
          
          // Ensure minimum visible size for tiny brushes
          if (currentSize < 1) {
            displaySize = Math.max(2, displaySize * 8); // Make tiny brushes more visible
          } else if (currentSize < 3) {
            displaySize = Math.max(4, displaySize * 2);
          }
          
          indicator.style.width = displaySize + 'px';
          indicator.style.height = displaySize + 'px';
          indicator.style.left = (e.clientX - displaySize / 2) + 'px';
          indicator.style.top = (e.clientY - displaySize / 2) + 'px';
          indicator.style.display = 'block';
          
          // Change indicator color for eraser
          if (currentTool === 'eraser') {
            indicator.style.borderColor = '#ff4444';
            indicator.style.background = 'radial-gradient(circle, rgba(255, 68, 68, 0.3), rgba(255, 68, 68, 0.1))';
          } else if (currentSize < 1) {
            // Special indicator for tiny brushes
            indicator.style.borderColor = '#00ff00';
            indicator.style.background = 'radial-gradient(circle, rgba(0, 255, 0, 0.4), rgba(0, 255, 0, 0.2))';
            indicator.style.borderWidth = '2px';
          } else {
            indicator.style.borderColor = '#ff6b9d';
            indicator.style.background = 'radial-gradient(circle, rgba(255, 107, 157, 0.3), rgba(78, 205, 196, 0.1))';
            indicator.style.borderWidth = '3px';
          }
        } else {
          indicator.style.display = 'none';
        }
      } else {
        indicator.style.display = 'none';
      }
    }

    function createInitialLayers() {
      // Create 3 initial layers
      for (let i = 0; i < 3; i++) {
        createLayer(i);
      }
      
      // Set first layer as active
      setActiveLayer(0);
    }

    function createLayer(index) {
      const container = document.getElementById('canvas-container');
      const canvasEl = document.createElement('canvas');
      
      canvasEl.id = `canvas-${index}`;
      canvasEl.style.position = 'absolute';
      canvasEl.style.top = '0';
      canvasEl.style.left = '0';
      canvasEl.style.zIndex = index;
      
      container.appendChild(canvasEl);
      
      const fabricCanvas = new fabric.Canvas(canvasEl, {
        width: CANVAS_WIDTH,
        height: CANVAS_HEIGHT,
        backgroundColor: index === 0 ? '#ffffff' : 'transparent'
      });
      
      // Configure drawing settings for tiny brushes
      fabricCanvas.freeDrawingBrush.width = currentSize;
      fabricCanvas.freeDrawingBrush.color = currentColor;
      fabricCanvas.isDrawingMode = false;
      
      // Enhanced drawing precision for tiny brushes
      fabricCanvas.selection = false;
      fabricCanvas.skipTargetFind = true;
      
      // Add drawing event listeners for undo/redo
      fabricCanvas.on('path:created', function() {
        saveState();
      });

      // Add fill tool click handler
      fabricCanvas.on('mouse:down', function(options) {
        if (currentTool === 'fill') {
          handleFillClick(options, fabricCanvas);
        }
      });
      
      canvases[index] = fabricCanvas;
      
      // Resize canvas to fit container
      resizeCanvas(fabricCanvas);
    }

    function setupCanvasContainer() {
      const container = document.getElementById('canvas-container');
      
      // Make sure all canvases fit the container
      canvases.forEach(canvas => {
        resizeCanvas(canvas);
      });
    }

    function resizeCanvas(canvas) {
      const container = document.getElementById('canvas-container');
      const containerRect = container.getBoundingClientRect();
      
      const scaleX = containerRect.width / CANVAS_WIDTH;
      const scaleY = containerRect.height / CANVAS_HEIGHT;
      const scale = Math.min(scaleX, scaleY);
      
      canvas.setDimensions({
        width: CANVAS_WIDTH * scale,
        height: CANVAS_HEIGHT * scale
      });
      
      canvas.setZoom(scale * zoomLevel);
    }

    // Enhanced Tiny Brush Function
    function setTinyBrush(size) {
      // Clear all tiny brush active states
      document.querySelectorAll('.tiny-brush-btn').forEach(btn => btn.classList.remove('active'));
      
      // Activate selected tiny brush
      const tinyId = `tiny-${size.toString().replace('.', '')}`;
      const tinyBtn = document.getElementById(tinyId);
      if (tinyBtn) tinyBtn.classList.add('active');
      
      // Set the size
      currentSize = size;
      isTinyBrushActive = true;
      
      // Update UI
      document.getElementById('brushSize').value = size;
      document.getElementById('sizeValue').textContent = size;
      
      // Update canvas and preview
      updateCurrentCanvas();
      updateBrushPreview();
      
      // Show feedback
      showToolMessage(`üî¨ Tiny brush ${size}px activated! Perfect for details! ‚ú®`);
      
      // Auto-zoom in for tiny brushes to help with precision
      if (zoomLevel < 2 && size < 1) {
        zoomLevel = 3;
        updateZoom();
        showToolMessage('üîç Auto-zoomed for tiny brush precision!');
      }
    }

    // Tool functions
    function setTool(tool) {
      // Remove active class from all tools
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      
      // Add active class to selected tool
      const toolBtn = document.getElementById(`${tool}-tool`);
      if (toolBtn) toolBtn.classList.add('active');
      
      currentTool = tool;
      updateCurrentCanvas();
      updateCursor();
      
      // Clear tiny brush selection when switching tools
      if (tool !== 'brush' && tool !== 'paintbrush' && tool !== 'pencil') {
        clearTinyBrushSelection();
      }
      
      // Show tool feedback
      showToolFeedback(tool);
    }

    function clearTinyBrushSelection() {
      document.querySelectorAll('.tiny-brush-btn').forEach(btn => btn.classList.remove('active'));
      isTinyBrushActive = false;
    }

    function showToolFeedback(tool) {
      const toolNames = {
        'brush': 'üñåÔ∏è Brush Tool',
        'paintbrush': 'üé® Paint Brush',
        'pencil': '‚úèÔ∏è Pencil Tool',
        'eraser': 'üßπ Eraser Tool',
        'fill': 'ü™£ Fill Bucket',
        'spray': 'üí® Spray Paint',
        'marker': 'üñçÔ∏è Marker Tool',
        'smudge': 'üëÜ Smudge Tool'
      };
      
      // Create temporary feedback element
      const feedback = document.createElement('div');
      feedback.textContent = toolNames[tool] || tool;
      feedback.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
        color: white;
        padding: 15px 30px;
        border-radius: 20px;
        font-size: 18px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => feedback.style.opacity = '1', 10);
      setTimeout(() => {
        feedback.style.opacity = '0';
        setTimeout(() => document.body.removeChild(feedback), 300);
      }, 1000);
    }

    function updateCursor() {
      const container = document.getElementById('canvas-container');
      
      // Remove all cursor classes
      container.classList.remove('fill-cursor', 'eraser-cursor');
      
      switch (currentTool) {
        case 'fill':
          container.classList.add('fill-cursor');
          break;
        case 'eraser':
          container.classList.add('eraser-cursor');
          break;
        default:
          container.style.cursor = 'crosshair';
      }
    }

    function updateCurrentCanvas() {
      const activeCanvas = canvases[currentLayerIndex];
      if (!activeCanvas) return;
      
      // Get actual brush size (enhanced for tiny brushes)
      let actualBrushSize = currentSize;
      
      switch (currentTool) {
        case 'brush':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          setupBrushSettings(activeCanvas);
          break;
          
        case 'paintbrush':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = createAdvancedBrush(activeCanvas);
          setupPaintBrushSettings(activeCanvas);
          break;
          
        case 'pencil':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          // Enhanced for tiny sizes
          if (currentSize < 1) {
            actualBrushSize = currentSize; // Keep exact tiny size
          } else {
            actualBrushSize = Math.max(0.1, currentSize * 0.4);
          }
          activeCanvas.freeDrawingBrush.width = actualBrushSize;
          activeCanvas.freeDrawingBrush.color = currentColor;
          activeCanvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
          break;
          
        case 'eraser':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.EraserBrush(activeCanvas);
          // Enhanced eraser sizing
          if (currentSize < 1) {
            actualBrushSize = currentSize * 1.5; // Slightly larger for tiny erasers
          } else {
            actualBrushSize = currentSize * 1.2;
          }
          activeCanvas.freeDrawingBrush.width = actualBrushSize;
          break;
          
        case 'fill':
          activeCanvas.isDrawingMode = false;
          break;
          
        case 'spray':
          activeCanvas.isDrawingMode = true;
          if (fabric.SprayBrush) {
            activeCanvas.freeDrawingBrush = new fabric.SprayBrush(activeCanvas);
            activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 3 : currentSize * 1.8;
            activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow);
            activeCanvas.freeDrawingBrush.density = Math.max(1, 40 - (currentHardness * 0.35));
          } else {
            activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
            activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 2 : currentSize * 1.5;
            activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow * 0.7);
          }
          break;
          
        case 'marker':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 2 : currentSize * 1.4;
          activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, 0.75 * currentOpacity);
          break;
          
        case 'smudge':
          activeCanvas.isDrawingMode = false;
          showToolMessage('üé® Smudge tool coming in next update! Try the soft brush for similar effects! ‚ú®');
          break;
          
        default:
          activeCanvas.isDrawingMode = false;
      }
    }

    function showToolMessage(message) {
      const messageEl = document.createElement('div');
      messageEl.textContent = message;
      messageEl.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4ecdc4, #45b7d1);
        color: white;
        padding: 15px 25px;
        border-radius: 15px;
        font-size: 16px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 300px;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.4s ease;
      `;
      
      document.body.appendChild(messageEl);
      
      setTimeout(() => {
        messageEl.style.opacity = '1';
        messageEl.style.transform = 'translateX(0)';
      }, 10);
      
      setTimeout(() => {
        messageEl.style.opacity = '0';
        messageEl.style.transform = 'translateX(100%)';
        setTimeout(() => document.body.removeChild(messageEl), 400);
      }, 3000);
    }

    function setupBrushSettings(canvas) {
      // Enhanced precision for tiny brushes
      let actualSize = currentSize;
      if (currentSize < 1 && isTinyBrushActive) {
        actualSize = currentSize; // Keep exact tiny size
      }
      
      canvas.freeDrawingBrush.width = actualSize;
      canvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow);
      canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
    }

    function createAdvancedBrush(canvas) {
      const brush = new fabric.PencilBrush(canvas);
      return brush;
    }

    function setupPaintBrushSettings(canvas) {
      const brush = canvas.freeDrawingBrush;
      
      // Enhanced size calculation for tiny brushes
      let effectiveSize;
      if (currentSize < 1) {
        effectiveSize = currentSize * (0.9 + (pressureSimulation * 0.1)); // Less pressure variation for tiny
      } else {
        effectiveSize = currentSize * (0.8 + (pressureSimulation * 0.4));
      }
      
      const effectiveOpacity = currentOpacity * currentFlow * (0.7 + (pressureSimulation * 0.3));
      
      brush.width = effectiveSize;
      brush.color = hexToRgba(currentColor, effectiveOpacity);
      
      // Apply brush type effects
      switch (currentBrushType) {
        case 'soft':
          brush.shadowBlur = currentSize < 1 ? Math.max(0.5, currentSize * 0.8) : Math.max(3, currentSize * 0.4 * (1 - currentHardness));
          brush.shadowColor = hexToRgba(currentColor, effectiveOpacity * 0.6);
          break;
        case 'hard':
          brush.shadowBlur = 0;
          brush.shadowColor = 'transparent';
          break;
        case 'texture':
          brush.width = effectiveSize * (0.9 + Math.random() * 0.2);
          break;
        default:
          brush.shadowBlur = currentSize < 1 ? Math.max(0.2, currentSize * 0.3) : Math.max(1, currentSize * 0.15 * (1 - currentHardness));
          brush.shadowColor = hexToRgba(currentColor, effectiveOpacity * 0.4);
      }
    }

    // Enhanced Fill tool implementation
    function handleFillClick(options, canvas) {
      const pointer = canvas.getPointer(options.e);
      const x = Math.floor(pointer.x);
      const y = Math.floor(pointer.y);
      
      // Get canvas context for pixel manipulation
      const ctx = canvas.getContext();
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixelData = imageData.data;
      
      // Get target color at click position
      const targetColor = getPixelColor(pixelData, x, y, canvas.width);
      const fillColor = hexToRgb(currentColor);
      
      // Don't fill if target and fill colors are the same
      if (colorsEqual(targetColor, fillColor)) return;
      
      // Show fill feedback
      showToolMessage('ü™£ Filling area with color...');
      
      // Perform flood fill
      floodFill(pixelData, x, y, targetColor, fillColor, canvas.width, canvas.height);
      
      // Apply the changes
      ctx.putImageData(imageData, 0, 0);
      canvas.renderAll();
      
      // Save state for undo
      saveState();
    }

    function getPixelColor(pixelData, x, y, width) {
      const index = (y * width + x) * 4;
      return {
        r: pixelData[index],
        g: pixelData[index + 1],
        b: pixelData[index + 2],
        a: pixelData[index + 3]
      };
    }

    function setPixelColor(pixelData, x, y, width, color) {
      const index = (y * width + x) * 4;
      pixelData[index] = color.r;
      pixelData[index + 1] = color.g;
      pixelData[index + 2] = color.b;
      pixelData[index + 3] = color.a || 255;
    }

    function colorsEqual(color1, color2) {
      return color1.r === color2.r && 
             color1.g === color2.g && 
             color1.b === color2.b && 
             color1.a === color2.a;
    }

    function floodFill(pixelData, startX, startY, targetColor, fillColor, width, height) {
      const stack = [{x: startX, y: startY}];
      const visited = new Set();
      
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        
        const key = y * width + x;
        if (visited.has(key)) continue;
        visited.add(key);
        
        const currentColor = getPixelColor(pixelData, x, y, width);
        if (!colorsEqual(currentColor, targetColor)) continue;
        
        setPixelColor(pixelData, x, y, width, fillColor);
        
        // Add neighboring pixels
        stack.push({x: x + 1, y: y});
        stack.push({x: x - 1, y: y});
        stack.push({x: x, y: y + 1});
        stack.push({x: x, y: y - 1});
      }
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 255
      } : null;
    }

    function hexToRgba(hex, opacity) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        const r = parseInt(result[1], 16);
        const g = parseInt(result[2], 16);
        const b = parseInt(result[3], 16);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
      }
      return hex;
    }

    // Brush type functions
    function setBrushType(type) {
      currentBrushType = type;
      
      document.querySelectorAll('.brush-type-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`${type}-brush`).classList.add('active');
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    // Color functions
    function selectColor(color) {
      currentColor = color;
      document.getElementById('colorPicker').value = color;
      
      document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
      const colorBtn = document.querySelector(`[onclick="selectColor('${color}')"]`);
      if (colorBtn) colorBtn.classList.add('active');
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    // Enhanced Brush settings for tiny brushes
    function updateBrushSize(size) {
      currentSize = parseFloat(size);
      
      // Clear tiny brush selection if not using preset tiny size
      const tinyPresets = [0.1, 0.2, 0.3, 0.5, 0.7, 0.8];
      if (!tinyPresets.includes(currentSize)) {
        clearTinyBrushSelection();
      }
      
      // Enhanced size display
      let displaySize = currentSize;
      if (currentSize < 1) {
        displaySize = currentSize.toFixed(1) + 'px';
      } else if (currentSize < 10) {
        displaySize = currentSize.toFixed(1);
      } else {
        displaySize = Math.round(currentSize);
      }
      
      document.getElementById('sizeValue').textContent = displaySize;
      document.getElementById('sizeDisplay').textContent = displaySize;
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateOpacity(opacity) {
      currentOpacity = opacity / 100;
      document.getElementById('opacityValue').textContent = opacity + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateFlow(flow) {
      currentFlow = flow / 100;
      document.getElementById('flowValue').textContent = flow + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateHardness(hardness) {
      currentHardness = hardness / 100;
      document.getElementById('hardnessValue').textContent = hardness + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateBrushPreview() {
      const preview = document.getElementById('brushPreview');
      
      // Enhanced preview sizing for tiny brushes
      let previewSize;
      if (currentSize < 1) {
        previewSize = Math.max(2, currentSize * 20); // Make tiny brushes visible in preview
      } else {
        previewSize = Math.max(3, currentSize / 4);
      }
      
      preview.style.width = previewSize + 'px';
      preview.style.height = previewSize + 'px';
      preview.style.backgroundColor = currentColor;
      preview.style.opacity = currentOpacity * currentFlow;
      
      // Apply brush type effects to preview
      switch (currentBrushType) {
        case 'soft':
          const blurAmount = currentSize < 1 ? Math.max(0.5, previewSize * 0.2) : Math.max(1, previewSize * 0.4 * (1 - currentHardness));
          preview.style.filter = `blur(${blurAmount}px)`;
          preview.style.boxShadow = `0 0 ${blurAmount * 3}px ${currentColor}`;
          break;
        case 'hard':
          preview.style.filter = 'none';
          preview.style.boxShadow = 'none';
          preview.style.borderRadius = currentSize < 1 ? '50%' : '3px';
          break;
        case 'texture':
          preview.style.filter = 'none';
          preview.style.boxShadow = `inset 0 0 ${previewSize}px rgba(0,0,0,0.4)`;
          preview.style.background = `linear-gradient(45deg, ${currentColor}, ${currentColor}dd)`;
          break;
        default:
          const softBlur = currentSize < 1 ? Math.max(0.2, previewSize * 0.1) : Math.max(0.5, previewSize * 0.15 * (1 - currentHardness));
          preview.style.filter = `blur(${softBlur}px)`;
          preview.style.boxShadow = `0 0 ${softBlur * 6}px ${currentColor}66`;
          preview.style.borderRadius = '50%';
      }
      
      // Special highlighting for tiny brushes
      if (currentSize < 1) {
        preview.style.border = '2px solid #00ff00';
        preview.style.animation = 'tinyGlow 2s ease-in-out infinite alternate';
      } else {
        preview.style.border = 'none';
        preview.style.animation = 'none';
      }
      
      updatePressureIndicator();
    }

    // Add tiny glow animation
    const tinyGlowStyle = document.createElement('style');
    tinyGlowStyle.textContent = `
      @keyframes tinyGlow {
        from { box-shadow: 0 0 5px #00ff00, inset 0 0 5px rgba(0, 255, 0, 0.2); }
        to { box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.4); }
      }
    `;
    document.head.appendChild(tinyGlowStyle);

    function updatePressureIndicator() {
      const pressureBar = document.getElementById('pressureBar');
      if (pressureBar) {
        pressureBar.style.width = (pressureSimulation * 100) + '%';
      }
    }

    function simulatePressureChange() {
      pressureSimulation = 0.4 + Math.random() * 0.6;
      updatePressureIndicator();
      
      if (currentTool === 'paintbrush' && canvases[currentLayerIndex]) {
        updateCurrentCanvas();
      }
    }

    setInterval(simulatePressureChange, 2500);

    // Layer functions
    function updateLayersPanel() {
      const panel = document.getElementById('layersPanel');
      panel.innerHTML = '';
      
      for (let i = canvases.length - 1; i >= 0; i--) {
        const layerItem = document.createElement('div');
        layerItem.className = `layer-item ${i === currentLayerIndex ? 'active' : ''}`;
        layerItem.onclick = () => setActiveLayer(i);
        
        layerItem.innerHTML = `
          <span>üé® Layer ${i + 1}</span>
          <div class="layer-controls">
            <button class="layer-control-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${i})" title="Toggle Visibility">üëÅÔ∏è</button>
            ${i > 0 ? `<button class="layer-control-btn" onclick="event.stopPropagation(); deleteLayer(${i})" title="Delete Layer">üóëÔ∏è</button>` : ''}
          </div>
        `;
        
        panel.appendChild(layerItem);
      }
    }

    function setActiveLayer(index) {
      canvases.forEach(canvas => {
        canvas.isDrawingMode = false;
      });
      
      currentLayerIndex = index;
      updateCurrentCanvas();
      updateLayersPanel();
      
      showToolMessage(`üé® Switched to Layer ${index + 1}`);
    }

    function addLayer() {
      if (canvases.length >= MAX_LAYERS) {
        showToolMessage('üìö Maximum number of layers reached! Try combining some layers first.');
        return;
      }
      
      const newIndex = canvases.length;
      createLayer(newIndex);
      setActiveLayer(newIndex);
      updateLayersPanel();
      
      showToolMessage(`‚ú® New Layer ${newIndex + 1} created!`);
    }

    function deleteLayer(index) {
      if (canvases.length <= 1) {
        showToolMessage('üö´ Cannot delete the last layer! Create a new layer first.');
        return;
      }
      
      const canvasEl = document.getElementById(`canvas-${index}`);
      if (canvasEl) {
        canvasEl.remove();
      }
      
      canvases.splice(index, 1);
      
      for (let i = index; i < canvases.length; i++) {
        const canvas = canvases[i];
        canvas.lowerCanvasEl.id = `canvas-${i}`;
        canvas.lowerCanvasEl.style.zIndex = i;
      }
      
      if (currentLayerIndex >= index) {
        currentLayerIndex = Math.max(0, currentLayerIndex - 1);
      }
      
      setActiveLayer(currentLayerIndex);
      updateLayersPanel();
      
      showToolMessage('üóëÔ∏è Layer deleted successfully!');
    }

    function toggleLayerVisibility(index) {
      const canvas = canvases[index];
      if (canvas) {
        const isVisible = canvas.lowerCanvasEl.style.display !== 'none';
        canvas.lowerCanvasEl.style.display = isVisible ? 'none' : 'block';
        canvas.upperCanvasEl.style.display = isVisible ? 'none' : 'block';
        
        showToolMessage(isVisible ? 'üëÅÔ∏è‚Äçüó®Ô∏è Layer hidden' : 'üëÅÔ∏è Layer visible');
      }
    }

    // Enhanced Zoom functions with tiny brush considerations
    function zoomIn() {
      zoomLevel = Math.min(zoomLevel * 1.25, 16.0); // Increased max zoom for tiny brushes
      updateZoom();
      showToolMessage(`üîç Zoomed in to ${Math.round(zoomLevel * 100)}%`);
    }

    function zoomOut() {
      zoomLevel = Math.max(zoomLevel / 1.25, 0.1);
      updateZoom();
      showToolMessage(`üîç Zoomed out to ${Math.round(zoomLevel * 100)}%`);
    }

    function updateZoom() {
      document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
      canvases.forEach(canvas => {
        resizeCanvas(canvas);
      });
    }

    // Enhanced Undo/Redo system
    function saveState() {
      const activeCanvas = canvases[currentLayerIndex];
      if (activeCanvas) {
        undoStack.push({
          layerIndex: currentLayerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        if (undoStack.length > 100) {
          undoStack.shift();
        }
        
        redoStack = [];
      }
    }

    function undoAction() {
      if (undoStack.length === 0) {
        showToolMessage('üö´ Nothing to undo!');
        return;
      }
      
      const currentState = undoStack.pop();
      const activeCanvas = canvases[currentState.layerIndex];
      
      if (activeCanvas) {
        redoStack.push({
          layerIndex: currentState.layerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        activeCanvas.loadFromJSON(currentState.state, () => {
          activeCanvas.renderAll();
        });
        
        showToolMessage('‚Ü∂ Undid last action');
      }
    }

    function redoAction() {
      if (redoStack.length === 0) {
        showToolMessage('üö´ Nothing to redo!');
        return;
      }
      
      const redoState = redoStack.pop();
      const activeCanvas = canvases[redoState.layerIndex];
      
      if (activeCanvas) {
        undoStack.push({
          layerIndex: redoState.layerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        activeCanvas.loadFromJSON(redoState.state, () => {
          activeCanvas.renderAll();
        });
        
        showToolMessage('‚Ü∑ Redid last action');
      }
    }

    function clearCurrentLayer() {
      if (confirm('üßº Clear this layer? This action cannot be undone!')) {
        const activeCanvas = canvases[currentLayerIndex];
        if (activeCanvas) {
          saveState();
          activeCanvas.clear();
          if (currentLayerIndex === 0) {
            activeCanvas.backgroundColor = '#ffffff';
          }
          activeCanvas.renderAll();
          
          showToolMessage('üßº Layer cleared successfully!');
        }
      }
    }
    
    function newProject() {
      if (confirm('üÜï Create a new canvas? Your current silly artwork will be lost!')) {
        undoStack = [];
        redoStack = [];
        
        canvases.forEach((canvas, index) => {
          canvas.clear();
          if (index === 0) {
            canvas.backgroundColor = '#ffffff';
          } else {
            canvas.backgroundColor = 'transparent';
          }
          canvas.renderAll();
        });
        
        currentLayerIndex = 0;
        zoomLevel = 1.0;
        updateZoom();
        updateLayersPanel();
        setActiveLayer(0);
        updateCurrentCanvas();
        
        showToolMessage('üÜï New canvas created! Start painting something silly! ‚ú®');
      }
    }
    
    function saveProject() {
      try {
        const projectData = {
          version: '2.1',
          app: 'Silly Paintings Painting World',
          timestamp: new Date().toISOString(),
          layers: [],
          settings: {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            currentLayer: currentLayerIndex,
            zoom: zoomLevel,
            brushSettings: {
              size: currentSize,
              color: currentColor,
              opacity: currentOpacity,
              flow: currentFlow,
              hardness: currentHardness,
              type: currentBrushType,
              tool: currentTool
            }
          }
        };
        
        canvases.forEach((canvas, index) => {
          projectData.layers.push({
            index: index,
            data: canvas.toJSON(),
            visible: canvas.lowerCanvasEl.style.display !== 'none'
          });
        });
        
        const dataStr = JSON.stringify(projectData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
        const exportFileDefaultName = `silly_painting_${timestamp}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showToolMessage('üíæ Silly painting saved successfully!');
        
      } catch (error) {
        showToolMessage('‚ùå Error saving project: ' + error.message);
      }
    }
    
    function loadProject() {
      document.getElementById('fileInput').click();
    }
    
    function handleFileLoad(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const projectData = JSON.parse(e.target.result);
          
          if (!projectData.layers || !Array.isArray(projectData.layers)) {
            throw new Error('Invalid project file format');
          }
          
          // Clear existing canvases
          canvases.forEach(canvas => {
            const canvasEl = canvas.lowerCanvasEl;
            if (canvasEl && canvasEl.parentNode) {
              canvasEl.parentNode.removeChild(canvasEl);
            }
          });
          canvases = [];
          
          // Load project layers
          projectData.layers.forEach((layerData, index) => {
            createLayer(index);
            const canvas = canvases[index];
            
            canvas.loadFromJSON(layerData.data, () => {
              canvas.renderAll();
              
              if (layerData.visible === false) {
                canvas.lowerCanvasEl.style.display = 'none';
                canvas.upperCanvasEl.style.display = 'none';
              }
            });
          });
          
          // Restore settings
          currentLayerIndex = projectData.settings?.currentLayer || 0;
          if (currentLayerIndex >= canvases.length) {
            currentLayerIndex = 0;
          }
          
          if (projectData.settings?.zoom) {
            zoomLevel = projectData.settings.zoom;
            updateZoom();
          }
          
          // Restore brush settings if available
          if (projectData.settings?.brushSettings) {
            const brushSettings = projectData.settings.brushSettings;
            
            if (brushSettings.size !== undefined) {
              currentSize = brushSettings.size;
              document.getElementById('brushSize').value = currentSize;
              updateBrushSize(currentSize);
            }
            
            if (brushSettings.color) {
              selectColor(brushSettings.color);
            }
            
            if (brushSettings.opacity !== undefined) {
              currentOpacity = brushSettings.opacity;
              document.getElementById('brushOpacity').value = currentOpacity * 100;
              updateOpacity(currentOpacity * 100);
            }
            
            if (brushSettings.type) {
              setBrushType(brushSettings.type);
            }
            
            if (brushSettings.tool) {
              setTool(brushSettings.tool);
            }
          }
          
          setActiveLayer(currentLayerIndex);
          updateLayersPanel();
          
          event.target.value = '';
          
          showToolMessage('üìÇ Silly painting loaded successfully!');
          
        } catch (error) {
          showToolMessage('‚ùå Error loading project: ' + error.message);
        }
      };
      
      reader.readAsText(file);
    }
    
    function exportPNG() {
      try {
        const mergedCanvas = document.createElement('canvas');
        mergedCanvas.width = CANVAS_WIDTH;
        mergedCanvas.height = CANVAS_HEIGHT;
        const ctx = mergedCanvas.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Merge all visible layers
        canvases.forEach(canvas => {
          if (canvas.lowerCanvasEl.style.display !== 'none') {
            ctx.drawImage(canvas.lowerCanvasEl, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          }
        });
        
        const image = mergedCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
        link.download = `silly_masterpiece_${timestamp}.png`;
        link.href = image;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showToolMessage('üì∑ Silly artwork exported successfully! üéâ');
        
      } catch (error) {
        showToolMessage('‚ùå Error exporting image: ' + error.message);
      }
    }

    // Enhanced touch support for mobile devices
    function addTouchSupport() {
      canvases.forEach(canvas => {
        const canvasEl = canvas.upperCanvasEl;
        
        // Prevent default touch behaviors
        canvasEl.addEventListener('touchstart', function(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
        
        canvasEl.addEventListener('touchmove', function(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
        
        canvasEl.addEventListener('touchend', function(e) {
          e.preventDefault();
          const mouseEvent = new MouseEvent('mouseup', {});
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
      });
    }

    // Easter eggs and fun interactions
    function addEasterEggs() {
      let clickCount = 0;
      const logo = document.querySelector('.logo');
      
      logo.addEventListener('click', function() {
        clickCount++;
        if (clickCount === 5) {
          // Rainbow effect
          this.style.background = 'linear-gradient(45deg, #ff6b9d, #4ecdc4, #45b7d1, #96ceb4, #ffa500, #ff6b9d)';
          this.style.webkitBackgroundClip = 'text';
          this.style.webkitTextFillColor = 'transparent';
          this.style.backgroundSize = '400% 400%';
          this.style.animation = 'rainbow 2s ease-in-out infinite';
          
          // Add sparkle effect
          createSparkles();
          
          showToolMessage('üåà You found the silly rainbow mode! Keep creating amazing silly art! ‚ú®');
          
          setTimeout(() => {
            clickCount = 0;
            this.style.background = '';
            this.style.webkitBackgroundClip = '';
            this.style.webkitTextFillColor = '';
            this.style.backgroundSize = '';
            this.style.animation = '';
          }, 8000);
        } else if (clickCount === 3) {
          showToolMessage('üéØ Almost there! Click 2 more times for a silly surprise! ‚ú®');
        }
      });
    }

    function createSparkles() {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.textContent = '‚ú®';
          sparkle.style.cssText = `
            position: fixed;
            font-size: ${Math.random() * 20 + 15}px;
            left: ${Math.random() * 100}vw;
            top: ${Math.random() * 100}vh;
            pointer-events: none;
            z-index: 10000;
            animation: sparkleFloat 3s ease-out forwards;
          `;
          
          const style = document.createElement('style');
          style.textContent = `
            @keyframes sparkleFloat {
              0% { opacity: 1; transform: translateY(0) rotate(0deg); }
              100% { opacity: 0; transform: translateY(-100px) rotate(360deg); }
            }
          `;
          document.head.appendChild(style);
          
          document.body.appendChild(sparkle);
          
          setTimeout(() => {
            if (document.body.contains(sparkle)) {
              document.body.removeChild(sparkle);
            }
          }, 3000);
        }, i * 100);
      }
    }

    // Rainbow animation keyframes
    const rainbowStyle = document.createElement('style');
    rainbowStyle.textContent = `
      @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
    `;
    document.head.appendChild(rainbowStyle);

    // Initialize everything when page loads
    setTimeout(() => {
      addTouchSupport();
      addEasterEggs();
    }, 2500);

    // Auto-save functionality (in memory)
    let autoSaveData = null;
    function autoSave() {
      try {
        const projectData = {
          version: '2.1',
          app: 'Silly Paintings Painting World',
          timestamp: new Date().toISOString(),
          layers: [],
          settings: {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            currentLayer: currentLayerIndex,
            zoom: zoomLevel,
            brushSettings: {
              size: currentSize,
              color: currentColor,
              opacity: currentOpacity,
              flow: currentFlow,
              hardness: currentHardness,
              type: currentBrushType,
              tool: currentTool
            }
          }
