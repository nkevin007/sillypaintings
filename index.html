<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Silly Paintings Painting World! - Digital Canvas</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
  <style>
    /* Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
      color: #fff;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="paint-dots" x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse"><circle cx="10" cy="10" r="1" fill="rgba(255,255,255,0.1)"/></pattern></defs><rect width="100" height="100" fill="url(%23paint-dots)"/></svg>');
      opacity: 0.3;
      pointer-events: none;
    }

    /* Header - Made larger and more colorful */
    .header {
      background: linear-gradient(90deg, rgba(255, 107, 157, 0.9), rgba(78, 205, 196, 0.9));
      padding: 20px 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      backdrop-filter: blur(15px);
      border-bottom: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }

    .logo {
      font-size: 32px;
      font-weight: 700;
      color: #fff;
      text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo::before {
      content: '🎨';
      font-size: 36px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    .header-actions {
      display: flex;
      gap: 15px;
    }

    .header-btn {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      padding: 12px 20px;
      border-radius: 25px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
      min-width: 100px;
    }

    .header-btn:hover {
      background: linear-gradient(45deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    /* Main Layout - Maximized canvas area */
    .main-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* Left Sidebar - Bigger tools */
    .left-sidebar {
      width: 120px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), rgba(50, 50, 100, 0.6));
      backdrop-filter: blur(15px);
      border-right: 3px solid rgba(255, 255, 255, 0.2);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 25px 15px;
      gap: 20px;
      box-shadow: 4px 0 20px rgba(0, 0, 0, 0.2);
    }

    .tool-btn {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px;
      color: white;
      font-size: 32px;
      cursor: pointer;
      transition: all 0.4s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .tool-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transition: left 0.6s;
    }

    .tool-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.2));
      transform: scale(1.1) rotate(5deg);
      border-color: #4ecdc4;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .tool-btn:hover::before {
      left: 100%;
    }

    .tool-btn.active {
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      border-color: #fff;
      box-shadow: 0 0 30px rgba(255, 107, 157, 0.8);
      transform: scale(1.05);
    }

    /* Canvas Area - Maximized */
    .canvas-area {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at center, #f8f9fa 0%, #e9ecef 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 15px;
    }

    #canvas-container {
      position: relative;
      background: linear-gradient(45deg, #ffffff, #f8f9ff);
      border-radius: 20px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      overflow: hidden;
      width: calc(100% - 30px);
      height: calc(100% - 30px);
      max-width: none;
      max-height: none;
      cursor: crosshair;
      border: 4px solid rgba(255, 255, 255, 0.8);
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      touch-action: none;
    }

    /* Right Sidebar - Enhanced visibility */
    .right-sidebar {
      width: 340px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.6), rgba(100, 50, 150, 0.6));
      backdrop-filter: blur(15px);
      border-left: 3px solid rgba(255, 255, 255, 0.2);
      padding: 25px;
      overflow-y: auto;
      box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
    }

    .sidebar-section {
      margin-bottom: 35px;
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .sidebar-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 20px;
      color: #4ecdc4;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      text-align: center;
    }

    /* Color Picker Section - Bigger colors */
    .color-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 20px;
    }

    .color-btn {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .color-btn:hover {
      transform: scale(1.2) rotate(10deg);
      border-color: #fff;
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.4);
    }

    .color-btn.active {
      border-color: #4ecdc4;
      border-width: 5px;
      box-shadow: 0 0 25px rgba(78, 205, 196, 0.8);
      transform: scale(1.1);
    }

    #colorPicker {
      width: 100%;
      height: 60px;
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 15px;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    /* Brush Settings - Enhanced sliders */
    .slider-container {
      margin-bottom: 25px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 12px;
      font-size: 16px;
      font-weight: 600;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .slider {
      width: 100%;
      height: 10px;
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.3), rgba(78, 205, 196, 0.3));
      outline: none;
      -webkit-appearance: none;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      border: 3px solid white;
    }

    .slider::-moz-range-thumb {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      cursor: pointer;
      border: 3px solid white;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced Tiny Brush Controls */
    .tiny-brush-section {
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.3), rgba(78, 205, 196, 0.2));
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 15px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .tiny-brush-title {
      font-size: 18px;
      font-weight: 700;
      color: #fff;
      text-align: center;
      margin-bottom: 15px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .tiny-brush-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }

    .tiny-brush-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 10px;
      color: white;
      cursor: pointer;
      padding: 10px 5px;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .tiny-brush-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: scale(1.05);
      border-color: #4ecdc4;
    }

    .tiny-brush-btn.active {
      border-color: #ff6b9d;
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.6), rgba(78, 205, 196, 0.4));
      box-shadow: 0 0 15px rgba(255, 107, 157, 0.5);
    }

    /* Brush controls - Better visibility */
    .brush-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .brush-type-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      color: white;
      cursor: pointer;
      padding: 15px 8px;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .brush-type-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.2));
      transform: scale(1.05);
      border-color: #4ecdc4;
    }

    .brush-type-btn.active {
      border-color: #ff6b9d;
      background: linear-gradient(135deg, rgba(255, 107, 157, 0.5), rgba(78, 205, 196, 0.3));
      box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);
    }

    /* Layer Panel - Enhanced */
    .layers-panel {
      background: rgba(255, 255, 255, 0.15);
      border-radius: 15px;
      padding: 20px;
      border: 2px solid rgba(255, 255, 255, 0.2);
    }

    .layer-item {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid rgba(255, 255, 255, 0.2);
      font-weight: 600;
      font-size: 16px;
    }

    .layer-item:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.2));
      transform: translateX(5px);
      border-color: #4ecdc4;
    }

    .layer-item.active {
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
      box-shadow: 0 0 25px rgba(255, 107, 157, 0.5);
      border-color: #fff;
    }

    .layer-controls {
      display: flex;
      gap: 8px;
    }

    .layer-control-btn {
      background: rgba(255, 255, 255, 0.3);
      border: 2px solid rgba(255, 255, 255, 0.5);
      width: 35px;
      height: 35px;
      border-radius: 8px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      transition: all 0.3s ease;
    }

    .layer-control-btn:hover {
      background: rgba(255, 255, 255, 0.6);
      transform: scale(1.1);
      border-color: #4ecdc4;
    }

    /* Enhanced Brush Preview with size display */
    .brush-preview {
      width: 100%;
      height: 80px;
      background: linear-gradient(135deg, #ffffff, #f0f8ff);
      border-radius: 15px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      border: 3px solid rgba(255, 255, 255, 0.5);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .brush-stroke {
      border-radius: 50%;
      background: #333;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      position: relative;
    }

    .size-display {
      position: absolute;
      bottom: 5px;
      right: 10px;
      font-size: 12px;
      font-weight: 600;
      color: rgba(0, 0, 0, 0.6);
      background: rgba(255, 255, 255, 0.8);
      padding: 2px 8px;
      border-radius: 8px;
    }

    /* Enhanced pressure indicator */
    .pressure-indicator {
      width: 100%;
      height: 25px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 15px;
      margin-bottom: 15px;
      position: relative;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .pressure-bar {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4, #ff6b9d, #ffa500);
      border-radius: 13px;
      transition: width 0.3s ease;
      width: 50%;
      box-shadow: 0 0 15px rgba(255, 107, 157, 0.5);
    }

    /* Bottom Toolbar - Enhanced zoom controls */
    .bottom-toolbar {
      background: linear-gradient(90deg, rgba(0, 0, 0, 0.7), rgba(50, 50, 100, 0.7));
      backdrop-filter: blur(15px);
      padding: 20px 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 30px;
      border-top: 3px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      background: rgba(255, 255, 255, 0.1);
      padding: 10px 20px;
      border-radius: 25px;
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .zoom-btn {
      background: linear-gradient(135deg, #4ecdc4, #45b7d1);
      border: 2px solid white;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      color: white;
      cursor: pointer;
      font-size: 24px;
      font-weight: bold;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .zoom-btn:hover {
      transform: scale(1.15);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
    }

    .zoom-level {
      min-width: 80px;
      text-align: center;
      font-weight: 700;
      font-size: 18px;
      color: #4ecdc4;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced action buttons */
    .action-btn {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1));
      border: 2px solid rgba(255, 255, 255, 0.4);
      padding: 12px 18px;
      border-radius: 20px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }

    .action-btn:hover {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0.3));
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }

    .action-btn.undo {
      background: linear-gradient(135deg, #ffa500, #ff8c00);
    }

    .action-btn.redo {
      background: linear-gradient(135deg, #32cd32, #228b22);
    }

    .action-btn.clear {
      background: linear-gradient(135deg, #ff6b6b, #ff5252);
    }

    /* Tool cursors */
    .fill-cursor {
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><path fill="white" stroke="black" stroke-width="2" d="M16 8l8 8-8 8-8-8z"/></svg>'), auto !important;
    }

    .eraser-cursor {
      cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><rect x="4" y="10" width="20" height="12" rx="3" fill="pink" stroke="black" stroke-width="2"/></svg>'), auto !important;
    }

    /* Tool size indicator - Enhanced */
    .size-indicator {
      position: fixed;
      pointer-events: none;
      border: 3px solid #ff6b9d;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 107, 157, 0.2), rgba(78, 205, 196, 0.1));
      z-index: 1000;
      display: none;
      box-shadow: 0 0 20px rgba(255, 107, 157, 0.5);
      min-width: 2px;
      min-height: 2px;
    }

    /* Loading animation - More colorful */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
      font-size: 24px;
      font-weight: 600;
    }

    .loading-spinner {
      width: 80px;
      height: 80px;
      border: 6px solid rgba(255, 255, 255, 0.3);
      border-top: 6px solid #ff6b9d;
      border-right: 6px solid #4ecdc4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 30px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* File input styling */
    .file-input {
      display: none;
    }

    /* Mobile responsiveness - Improved */
    @media (max-width: 1024px) {
      .right-sidebar {
        width: 300px;
      }
      
      .tool-btn {
        width: 70px;
        height: 70px;
        font-size: 28px;
      }
      
      .left-sidebar {
        width: 100px;
      }
    }

    @media (max-width: 768px) {
      .header {
        padding: 15px 20px;
      }
      
      .logo {
        font-size: 24px;
      }
      
      .header-btn {
        padding: 10px 15px;
        font-size: 14px;
        min-width: 80px;
      }
      
      .main-container {
        flex-direction: column;
      }
      
      .left-sidebar {
        width: 100%;
        height: 100px;
        flex-direction: row;
        padding: 15px 20px;
        overflow-x: auto;
        gap: 15px;
      }
      
      .tool-btn {
        min-width: 70px;
        height: 70px;
        font-size: 24px;
      }
      
      .right-sidebar {
        width: 100%;
        height: 250px;
        overflow-y: auto;
      }
      
      .bottom-toolbar {
        padding: 15px 20px;
        gap: 20px;
      }
    }

    /* Tooltip styles */
    .tool-btn::after {
      content: attr(title);
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }

    .tool-btn:hover::after {
      opacity: 1;
    }

    /* Add some visual flair */
    .sidebar-section:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    /* Enhanced canvas container with animated border */
    #canvas-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #ff6b9d, #4ecdc4, #45b7d1, #ff6b9d);
      border-radius: 22px;
      z-index: -1;
      animation: borderGlow 3s linear infinite;
      background-size: 200% 200%;
    }

    @keyframes borderGlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
  </style>
</head>
<body>
  <div class="loading" id="loadingScreen">
    <div class="loading-spinner"></div>
    <div>Loading Silly Paintings Painting World...</div>
    <div style="font-size: 16px; margin-top: 15px; opacity: 0.8;">Get ready to create something silly and beautiful! ✨</div>
  </div>

  <div class="header">
    <div class="logo">Silly Paintings Painting World!</div>
    <div class="header-actions">
      <button class="header-btn" onclick="newProject()">🆕 New Canvas</button>
      <button class="header-btn" onclick="saveProject()">💾 Save Art</button>
      <button class="header-btn" onclick="loadProject()">📂 Load Art</button>
      <button class="header-btn" onclick="exportPNG()">📷 Download</button>
    </div>
  </div>

  <div class="main-container">
    <div class="left-sidebar">
      <button class="tool-btn active" onclick="setTool('brush')" title="Brush Tool" id="brush-tool">
        🖌️
      </button>
      <button class="tool-btn" onclick="setTool('paintbrush')" title="Paint Brush" id="paintbrush-tool">
        🎨
      </button>
      <button class="tool-btn" onclick="setTool('pencil')" title="Pencil Tool" id="pencil-tool">
        ✏️
      </button>
      <button class="tool-btn" onclick="setTool('eraser')" title="Eraser Tool" id="eraser-tool">
        🧹
      </button>
      <button class="tool-btn" onclick="setTool('fill')" title="Fill Bucket" id="fill-tool">
        🪣
      </button>
      <button class="tool-btn" onclick="setTool('spray')" title="Spray Paint" id="spray-tool">
        💨
      </button>
      <button class="tool-btn" onclick="setTool('marker')" title="Marker Tool" id="marker-tool">
        🖍️
      </button>
      <button class="tool-btn" onclick="setTool('smudge')" title="Smudge Tool" id="smudge-tool">
        👆
      </button>
    </div>

    <div class="canvas-area">
      <div id="canvas-container"></div>
      <div class="size-indicator" id="sizeIndicator"></div>
    </div>

    <div class="right-sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">🌈 Colors</div>
        <div class="color-grid">
          <div class="color-btn active" style="background: #000;" onclick="selectColor('#000000')" title="Black"></div>
          <div class="color-btn" style="background: #fff;" onclick="selectColor('#ffffff')" title="White"></div>
          <div class="color-btn" style="background: #ff0000;" onclick="selectColor('#ff0000')" title="Red"></div>
          <div class="color-btn" style="background: #00ff00;" onclick="selectColor('#00ff00')" title="Green"></div>
          <div class="color-btn" style="background: #0000ff;" onclick="selectColor('#0000ff')" title="Blue"></div>
          <div class="color-btn" style="background: #ffff00;" onclick="selectColor('#ffff00')" title="Yellow"></div>
          <div class="color-btn" style="background: #ff00ff;" onclick="selectColor('#ff00ff')" title="Magenta"></div>
          <div class="color-btn" style="background: #00ffff;" onclick="selectColor('#00ffff')" title="Cyan"></div>
          <div class="color-btn" style="background: #ffa500;" onclick="selectColor('#ffa500')" title="Orange"></div>
          <div class="color-btn" style="background: #800080;" onclick="selectColor('#800080')" title="Purple"></div>
          <div class="color-btn" style="background: #ffc0cb;" onclick="selectColor('#ffc0cb')" title="Pink"></div>
          <div class="color-btn" style="background: #90ee90;" onclick="selectColor('#90ee90')" title="Light Green"></div>
        </div>
        <input type="color" id="colorPicker" value="#000000" onchange="selectColor(this.value)">
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🖌️ Brush Settings</div>
        <div class="brush-preview">
          <div class="brush-stroke" id="brushPreview"></div>
          <div class="size-display" id="sizeDisplay">15px</div>
        </div>
        
        <!-- New Tiny Brush Section -->
        <div class="tiny-brush-section">
          <div class="tiny-brush-title">🔬 Tiny Brushes</div>
          <div class="tiny-brush-grid">
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.1)" id="tiny-01">0.1px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.2)" id="tiny-02">0.2px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.3)" id="tiny-03">0.3px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.5)" id="tiny-05">0.5px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.7)" id="tiny-07">0.7px</button>
            <button class="tiny-brush-btn" onclick="setTinyBrush(0.8)" id="tiny-08">0.8px</button>
          </div>
        </div>
        
        <div class="brush-controls">
          <button class="brush-type-btn active" onclick="setBrushType('normal')" id="normal-brush">Normal</button>
          <button class="brush-type-btn" onclick="setBrushType('texture')" id="texture-brush">Textured</button>
          <button class="brush-type-btn" onclick="setBrushType('soft')" id="soft-brush">Soft</button>
          <button class="brush-type-btn" onclick="setBrushType('hard')" id="hard-brush">Hard</button>
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>📏 Size</span>
            <span id="sizeValue">15</span>
          </div>
          <input type="range" class="slider" id="brushSize" min="0.1" max="200" step="0.1" value="15" oninput="updateBrushSize(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>💧 Opacity</span>
            <span id="opacityValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushOpacity" min="1" max="100" value="100" oninput="updateOpacity(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>🌊 Flow</span>
            <span id="flowValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushFlow" min="1" max="100" value="100" oninput="updateFlow(this.value)">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>⚡ Hardness</span>
            <span id="hardnessValue">100%</span>
          </div>
          <input type="range" class="slider" id="brushHardness" min="0" max="100" value="100" oninput="updateHardness(this.value)">
        </div>
        
        <div class="pressure-indicator" title="Brush Pressure">
          <div class="pressure-bar" id="pressureBar"></div>
        </div>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">📚 Drawing Layers</div>
        <div class="layers-panel" id="layersPanel">
        </div>
        <button class="header-btn" onclick="addLayer()" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #4ecdc4, #45b7d1);">➕ Add New Layer</button>
      </div>
    </div>
  </div>

  <div class="bottom-toolbar">
    <div class="zoom-controls">
      <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">-</button>
      <div class="zoom-level" id="zoomLevel">100%</div>
      <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
    </div>
    <button class="action-btn undo" onclick="undoAction()" title="Undo Last Action">↶ Undo</button>
    <button class="action-btn redo" onclick="redoAction()" title="Redo Last Action">↷ Redo</button>
    <button class="action-btn clear" onclick="clearCurrentLayer()" title="Clear Current Layer">🧼 Clear Layer</button>
  </div>

  <input type="file" id="fileInput" class="file-input" accept=".json" onchange="handleFileLoad(event)">

  <script>
    // Global variables
    let canvases = [];
    let currentLayerIndex = 0;
    let currentTool = 'brush';
    let currentBrushType = 'normal';
    let currentColor = '#000000';
    let currentSize = 15;
    let currentOpacity = 1.0;
    let currentFlow = 1.0;
    let currentHardness = 1.0;
    let zoomLevel = 1.0;
    let isDrawing = false;
    let undoStack = [];
    let redoStack = [];
    let pressureSimulation = 0.5;
    let isMouseDown = false;
    let isTinyBrushActive = false;
    
    // Canvas settings - Maximized for students
    const CANVAS_WIDTH = 1400;
    const CANVAS_HEIGHT = 900;
    const MAX_LAYERS = 10;

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        initializeApp();
        document.getElementById('loadingScreen').style.display = 'none';
      }, 2000);
    });

    function initializeApp() {
      createInitialLayers();
      setupCanvasContainer();
      updateLayersPanel();
      updateBrushPreview();
      setupEventListeners();
      showWelcomeMessage();
    }

    function showWelcomeMessage() {
      setTimeout(() => {
        alert('🎨 Welcome to Silly Paintings Painting World! 🎨\n\n✨ Tips for amazing silly art:\n• Use [/] keys to change brush size quickly\n• Try the new TINY brushes for super detailed work!\n• Use different brush types for cool effects\n• Use layers to organize your silly artwork\n• Don\'t forget to save your masterpiece!\n\nHappy silly painting! 🌈');
      }, 1000);
    }

    function setupEventListeners() {
      // Window resize handler
      window.addEventListener('resize', () => {
        canvases.forEach(canvas => {
          resizeCanvas(canvas);
        });
      });

      // Mouse move for size indicator
      document.addEventListener('mousemove', updateSizeIndicator);

      // Enhanced keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key) {
            case 'z':
              e.preventDefault();
              if (e.shiftKey) {
                redoAction();
              } else {
                undoAction();
              }
              break;
            case 'n':
              e.preventDefault();
              newProject();
              break;
            case 's':
              e.preventDefault();
              saveProject();
              break;
            case '=':
            case '+':
              e.preventDefault();
              zoomIn();
              break;
            case '-':
              e.preventDefault();
              zoomOut();
              break;
          }
        }
        
        // Tool shortcuts
        switch (e.key) {
          case 'b':
            setTool('brush');
            break;
          case 'p':
            if (!e.ctrlKey && !e.metaKey) setTool('paintbrush');
            break;
          case 'e':
            if (!e.ctrlKey && !e.metaKey) setTool('eraser');
            break;
          case 'f':
            setTool('fill');
            break;
          case 's':
            if (!e.ctrlKey && !e.metaKey) setTool('spray');
            break;
          case 'm':
            setTool('marker');
            break;
          case '1':
          case '2':
          case '3':
          case '4':
            const brushTypes = ['normal', 'texture', 'soft', 'hard'];
            const brushType = brushTypes[parseInt(e.key) - 1];
            if (brushType) setBrushType(brushType);
            break;
          case '[':
            // Decrease brush size (enhanced for tiny sizes)
            e.preventDefault();
            let newSizeDown;
            if (currentSize <= 1) {
              newSizeDown = Math.max(0.1, currentSize - 0.1);
            } else if (currentSize <= 5) {
              newSizeDown = Math.max(0.1, currentSize - 0.5);
            } else {
              newSizeDown = Math.max(0.1, currentSize - 5);
            }
            updateBrushSize(newSizeDown);
            document.getElementById('brushSize').value = newSizeDown;
            break;
          case ']':
            // Increase brush size (enhanced for tiny sizes)
            e.preventDefault();
            let newSizeUp;
            if (currentSize < 1) {
              newSizeUp = Math.min(200, currentSize + 0.1);
            } else if (currentSize < 5) {
              newSizeUp = Math.min(200, currentSize + 0.5);
            } else {
              newSizeUp = Math.min(200, currentSize + 5);
            }
            updateBrushSize(newSizeUp);
            document.getElementById('brushSize').value = newSizeUp;
            break;
          case 'Delete':
          case 'Backspace':
            if (e.ctrlKey) {
              e.preventDefault();
              clearCurrentLayer();
            }
            break;
        }
      });
    }

    function updateSizeIndicator(e) {
      const indicator = document.getElementById('sizeIndicator');
      const canvasContainer = document.getElementById('canvas-container');
      const containerRect = canvasContainer.getBoundingClientRect();
      
      // Only show indicator when hovering over canvas
      if (e.clientX >= containerRect.left && e.clientX <= containerRect.right &&
          e.clientY >= containerRect.top && e.clientY <= containerRect.bottom) {
        
        if (currentTool === 'brush' || currentTool === 'paintbrush' || 
            currentTool === 'pencil' || currentTool === 'eraser' || 
            currentTool === 'spray' || currentTool === 'marker') {
          
          // Enhanced size calculation for tiny brushes
          let displaySize = currentSize * (containerRect.width / CANVAS_WIDTH) * zoomLevel;
          
          // Ensure minimum visible size for tiny brushes
          if (currentSize < 1) {
            displaySize = Math.max(2, displaySize * 8); // Make tiny brushes more visible
          } else if (currentSize < 3) {
            displaySize = Math.max(4, displaySize * 2);
          }
          
          indicator.style.width = displaySize + 'px';
          indicator.style.height = displaySize + 'px';
          indicator.style.left = (e.clientX - displaySize / 2) + 'px';
          indicator.style.top = (e.clientY - displaySize / 2) + 'px';
          indicator.style.display = 'block';
          
          // Change indicator color for eraser
          if (currentTool === 'eraser') {
            indicator.style.borderColor = '#ff4444';
            indicator.style.background = 'radial-gradient(circle, rgba(255, 68, 68, 0.3), rgba(255, 68, 68, 0.1))';
          } else if (currentSize < 1) {
            // Special indicator for tiny brushes
            indicator.style.borderColor = '#00ff00';
            indicator.style.background = 'radial-gradient(circle, rgba(0, 255, 0, 0.4), rgba(0, 255, 0, 0.2))';
            indicator.style.borderWidth = '2px';
          } else {
            indicator.style.borderColor = '#ff6b9d';
            indicator.style.background = 'radial-gradient(circle, rgba(255, 107, 157, 0.3), rgba(78, 205, 196, 0.1))';
            indicator.style.borderWidth = '3px';
          }
        } else {
          indicator.style.display = 'none';
        }
      } else {
        indicator.style.display = 'none';
      }
    }

    function createInitialLayers() {
      // Create 3 initial layers
      for (let i = 0; i < 3; i++) {
        createLayer(i);
      }
      
      // Set first layer as active
      setActiveLayer(0);
    }

    function createLayer(index) {
      const container = document.getElementById('canvas-container');
      const canvasEl = document.createElement('canvas');
      
      canvasEl.id = `canvas-${index}`;
      canvasEl.style.position = 'absolute';
      canvasEl.style.top = '0';
      canvasEl.style.left = '0';
      canvasEl.style.zIndex = index;
      
      container.appendChild(canvasEl);
      
      const fabricCanvas = new fabric.Canvas(canvasEl, {
        width: CANVAS_WIDTH,
        height: CANVAS_HEIGHT,
        backgroundColor: index === 0 ? '#ffffff' : 'transparent'
      });
      
      // Configure drawing settings for tiny brushes
      fabricCanvas.freeDrawingBrush.width = currentSize;
      fabricCanvas.freeDrawingBrush.color = currentColor;
      fabricCanvas.isDrawingMode = false;
      
      // Enhanced drawing precision for tiny brushes
      fabricCanvas.selection = false;
      fabricCanvas.skipTargetFind = true;
      
      // Add drawing event listeners for undo/redo
      fabricCanvas.on('path:created', function() {
        saveState();
      });

      // Add fill tool click handler
      fabricCanvas.on('mouse:down', function(options) {
        if (currentTool === 'fill') {
          handleFillClick(options, fabricCanvas);
        }
      });
      
      canvases[index] = fabricCanvas;
      
      // Resize canvas to fit container
      resizeCanvas(fabricCanvas);
    }

    function setupCanvasContainer() {
      const container = document.getElementById('canvas-container');
      
      // Make sure all canvases fit the container
      canvases.forEach(canvas => {
        resizeCanvas(canvas);
      });
    }

    function resizeCanvas(canvas) {
      const container = document.getElementById('canvas-container');
      const containerRect = container.getBoundingClientRect();
      
      const scaleX = containerRect.width / CANVAS_WIDTH;
      const scaleY = containerRect.height / CANVAS_HEIGHT;
      const scale = Math.min(scaleX, scaleY);
      
      canvas.setDimensions({
        width: CANVAS_WIDTH * scale,
        height: CANVAS_HEIGHT * scale
      });
      
      canvas.setZoom(scale * zoomLevel);
    }

    // Enhanced Tiny Brush Function
    function setTinyBrush(size) {
      // Clear all tiny brush active states
      document.querySelectorAll('.tiny-brush-btn').forEach(btn => btn.classList.remove('active'));
      
      // Activate selected tiny brush
      const tinyId = `tiny-${size.toString().replace('.', '')}`;
      const tinyBtn = document.getElementById(tinyId);
      if (tinyBtn) tinyBtn.classList.add('active');
      
      // Set the size
      currentSize = size;
      isTinyBrushActive = true;
      
      // Update UI
      document.getElementById('brushSize').value = size;
      document.getElementById('sizeValue').textContent = size;
      
      // Update canvas and preview
      updateCurrentCanvas();
      updateBrushPreview();
      
      // Show feedback
      showToolMessage(`🔬 Tiny brush ${size}px activated! Perfect for details! ✨`);
      
      // Auto-zoom in for tiny brushes to help with precision
      if (zoomLevel < 2 && size < 1) {
        zoomLevel = 3;
        updateZoom();
        showToolMessage('🔍 Auto-zoomed for tiny brush precision!');
      }
    }

    // Tool functions
    function setTool(tool) {
      // Remove active class from all tools
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
      
      // Add active class to selected tool
      const toolBtn = document.getElementById(`${tool}-tool`);
      if (toolBtn) toolBtn.classList.add('active');
      
      currentTool = tool;
      updateCurrentCanvas();
      updateCursor();
      
      // Clear tiny brush selection when switching tools
      if (tool !== 'brush' && tool !== 'paintbrush' && tool !== 'pencil') {
        clearTinyBrushSelection();
      }
      
      // Show tool feedback
      showToolFeedback(tool);
    }

    function clearTinyBrushSelection() {
      document.querySelectorAll('.tiny-brush-btn').forEach(btn => btn.classList.remove('active'));
      isTinyBrushActive = false;
    }

    function showToolFeedback(tool) {
      const toolNames = {
        'brush': '🖌️ Brush Tool',
        'paintbrush': '🎨 Paint Brush',
        'pencil': '✏️ Pencil Tool',
        'eraser': '🧹 Eraser Tool',
        'fill': '🪣 Fill Bucket',
        'spray': '💨 Spray Paint',
        'marker': '🖍️ Marker Tool',
        'smudge': '👆 Smudge Tool'
      };
      
      // Create temporary feedback element
      const feedback = document.createElement('div');
      feedback.textContent = toolNames[tool] || tool;
      feedback.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #ff6b9d, #4ecdc4);
        color: white;
        padding: 15px 30px;
        border-radius: 20px;
        font-size: 18px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      
      document.body.appendChild(feedback);
      
      setTimeout(() => feedback.style.opacity = '1', 10);
      setTimeout(() => {
        feedback.style.opacity = '0';
        setTimeout(() => document.body.removeChild(feedback), 300);
      }, 1000);
    }

    function updateCursor() {
      const container = document.getElementById('canvas-container');
      
      // Remove all cursor classes
      container.classList.remove('fill-cursor', 'eraser-cursor');
      
      switch (currentTool) {
        case 'fill':
          container.classList.add('fill-cursor');
          break;
        case 'eraser':
          container.classList.add('eraser-cursor');
          break;
        default:
          container.style.cursor = 'crosshair';
      }
    }

    function updateCurrentCanvas() {
      const activeCanvas = canvases[currentLayerIndex];
      if (!activeCanvas) return;
      
      // Get actual brush size (enhanced for tiny brushes)
      let actualBrushSize = currentSize;
      
      switch (currentTool) {
        case 'brush':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          setupBrushSettings(activeCanvas);
          break;
          
        case 'paintbrush':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = createAdvancedBrush(activeCanvas);
          setupPaintBrushSettings(activeCanvas);
          break;
          
        case 'pencil':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          // Enhanced for tiny sizes
          if (currentSize < 1) {
            actualBrushSize = currentSize; // Keep exact tiny size
          } else {
            actualBrushSize = Math.max(0.1, currentSize * 0.4);
          }
          activeCanvas.freeDrawingBrush.width = actualBrushSize;
          activeCanvas.freeDrawingBrush.color = currentColor;
          activeCanvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
          break;
          
        case 'eraser':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.EraserBrush(activeCanvas);
          // Enhanced eraser sizing
          if (currentSize < 1) {
            actualBrushSize = currentSize * 1.5; // Slightly larger for tiny erasers
          } else {
            actualBrushSize = currentSize * 1.2;
          }
          activeCanvas.freeDrawingBrush.width = actualBrushSize;
          break;
          
        case 'fill':
          activeCanvas.isDrawingMode = false;
          break;
          
        case 'spray':
          activeCanvas.isDrawingMode = true;
          if (fabric.SprayBrush) {
            activeCanvas.freeDrawingBrush = new fabric.SprayBrush(activeCanvas);
            activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 3 : currentSize * 1.8;
            activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow);
            activeCanvas.freeDrawingBrush.density = Math.max(1, 40 - (currentHardness * 0.35));
          } else {
            activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
            activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 2 : currentSize * 1.5;
            activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow * 0.7);
          }
          break;
          
        case 'marker':
          activeCanvas.isDrawingMode = true;
          activeCanvas.freeDrawingBrush = new fabric.PencilBrush(activeCanvas);
          activeCanvas.freeDrawingBrush.width = currentSize < 1 ? currentSize * 2 : currentSize * 1.4;
          activeCanvas.freeDrawingBrush.color = hexToRgba(currentColor, 0.75 * currentOpacity);
          break;
          
        case 'smudge':
          activeCanvas.isDrawingMode = false;
          showToolMessage('🎨 Smudge tool coming in next update! Try the soft brush for similar effects! ✨');
          break;
          
        default:
          activeCanvas.isDrawingMode = false;
      }
    }

    function showToolMessage(message) {
      const messageEl = document.createElement('div');
      messageEl.textContent = message;
      messageEl.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4ecdc4, #45b7d1);
        color: white;
        padding: 15px 25px;
        border-radius: 15px;
        font-size: 16px;
        font-weight: 600;
        z-index: 10000;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        max-width: 300px;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.4s ease;
      `;
      
      document.body.appendChild(messageEl);
      
      setTimeout(() => {
        messageEl.style.opacity = '1';
        messageEl.style.transform = 'translateX(0)';
      }, 10);
      
      setTimeout(() => {
        messageEl.style.opacity = '0';
        messageEl.style.transform = 'translateX(100%)';
        setTimeout(() => document.body.removeChild(messageEl), 400);
      }, 3000);
    }

    function setupBrushSettings(canvas) {
      // Enhanced precision for tiny brushes
      let actualSize = currentSize;
      if (currentSize < 1 && isTinyBrushActive) {
        actualSize = currentSize; // Keep exact tiny size
      }
      
      canvas.freeDrawingBrush.width = actualSize;
      canvas.freeDrawingBrush.color = hexToRgba(currentColor, currentOpacity * currentFlow);
      canvas.freeDrawingBrush.globalCompositeOperation = 'source-over';
    }

    function createAdvancedBrush(canvas) {
      const brush = new fabric.PencilBrush(canvas);
      return brush;
    }

    function setupPaintBrushSettings(canvas) {
      const brush = canvas.freeDrawingBrush;
      
      // Enhanced size calculation for tiny brushes
      let effectiveSize;
      if (currentSize < 1) {
        effectiveSize = currentSize * (0.9 + (pressureSimulation * 0.1)); // Less pressure variation for tiny
      } else {
        effectiveSize = currentSize * (0.8 + (pressureSimulation * 0.4));
      }
      
      const effectiveOpacity = currentOpacity * currentFlow * (0.7 + (pressureSimulation * 0.3));
      
      brush.width = effectiveSize;
      brush.color = hexToRgba(currentColor, effectiveOpacity);
      
      // Apply brush type effects
      switch (currentBrushType) {
        case 'soft':
          brush.shadowBlur = currentSize < 1 ? Math.max(0.5, currentSize * 0.8) : Math.max(3, currentSize * 0.4 * (1 - currentHardness));
          brush.shadowColor = hexToRgba(currentColor, effectiveOpacity * 0.6);
          break;
        case 'hard':
          brush.shadowBlur = 0;
          brush.shadowColor = 'transparent';
          break;
        case 'texture':
          brush.width = effectiveSize * (0.9 + Math.random() * 0.2);
          break;
        default:
          brush.shadowBlur = currentSize < 1 ? Math.max(0.2, currentSize * 0.3) : Math.max(1, currentSize * 0.15 * (1 - currentHardness));
          brush.shadowColor = hexToRgba(currentColor, effectiveOpacity * 0.4);
      }
    }

    // Enhanced Fill tool implementation
    function handleFillClick(options, canvas) {
      const pointer = canvas.getPointer(options.e);
      const x = Math.floor(pointer.x);
      const y = Math.floor(pointer.y);
      
      // Get canvas context for pixel manipulation
      const ctx = canvas.getContext();
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixelData = imageData.data;
      
      // Get target color at click position
      const targetColor = getPixelColor(pixelData, x, y, canvas.width);
      const fillColor = hexToRgb(currentColor);
      
      // Don't fill if target and fill colors are the same
      if (colorsEqual(targetColor, fillColor)) return;
      
      // Show fill feedback
      showToolMessage('🪣 Filling area with color...');
      
      // Perform flood fill
      floodFill(pixelData, x, y, targetColor, fillColor, canvas.width, canvas.height);
      
      // Apply the changes
      ctx.putImageData(imageData, 0, 0);
      canvas.renderAll();
      
      // Save state for undo
      saveState();
    }

    function getPixelColor(pixelData, x, y, width) {
      const index = (y * width + x) * 4;
      return {
        r: pixelData[index],
        g: pixelData[index + 1],
        b: pixelData[index + 2],
        a: pixelData[index + 3]
      };
    }

    function setPixelColor(pixelData, x, y, width, color) {
      const index = (y * width + x) * 4;
      pixelData[index] = color.r;
      pixelData[index + 1] = color.g;
      pixelData[index + 2] = color.b;
      pixelData[index + 3] = color.a || 255;
    }

    function colorsEqual(color1, color2) {
      return color1.r === color2.r && 
             color1.g === color2.g && 
             color1.b === color2.b && 
             color1.a === color2.a;
    }

    function floodFill(pixelData, startX, startY, targetColor, fillColor, width, height) {
      const stack = [{x: startX, y: startY}];
      const visited = new Set();
      
      while (stack.length > 0) {
        const {x, y} = stack.pop();
        
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        
        const key = y * width + x;
        if (visited.has(key)) continue;
        visited.add(key);
        
        const currentColor = getPixelColor(pixelData, x, y, width);
        if (!colorsEqual(currentColor, targetColor)) continue;
        
        setPixelColor(pixelData, x, y, width, fillColor);
        
        // Add neighboring pixels
        stack.push({x: x + 1, y: y});
        stack.push({x: x - 1, y: y});
        stack.push({x: x, y: y + 1});
        stack.push({x: x, y: y - 1});
      }
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16),
        a: 255
      } : null;
    }

    function hexToRgba(hex, opacity) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (result) {
        const r = parseInt(result[1], 16);
        const g = parseInt(result[2], 16);
        const b = parseInt(result[3], 16);
        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
      }
      return hex;
    }

    // Brush type functions
    function setBrushType(type) {
      currentBrushType = type;
      
      document.querySelectorAll('.brush-type-btn').forEach(btn => btn.classList.remove('active'));
      document.getElementById(`${type}-brush`).classList.add('active');
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    // Color functions
    function selectColor(color) {
      currentColor = color;
      document.getElementById('colorPicker').value = color;
      
      document.querySelectorAll('.color-btn').forEach(btn => btn.classList.remove('active'));
      const colorBtn = document.querySelector(`[onclick="selectColor('${color}')"]`);
      if (colorBtn) colorBtn.classList.add('active');
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    // Enhanced Brush settings for tiny brushes
    function updateBrushSize(size) {
      currentSize = parseFloat(size);
      
      // Clear tiny brush selection if not using preset tiny size
      const tinyPresets = [0.1, 0.2, 0.3, 0.5, 0.7, 0.8];
      if (!tinyPresets.includes(currentSize)) {
        clearTinyBrushSelection();
      }
      
      // Enhanced size display
      let displaySize = currentSize;
      if (currentSize < 1) {
        displaySize = currentSize.toFixed(1) + 'px';
      } else if (currentSize < 10) {
        displaySize = currentSize.toFixed(1);
      } else {
        displaySize = Math.round(currentSize);
      }
      
      document.getElementById('sizeValue').textContent = displaySize;
      document.getElementById('sizeDisplay').textContent = displaySize;
      
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateOpacity(opacity) {
      currentOpacity = opacity / 100;
      document.getElementById('opacityValue').textContent = opacity + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateFlow(flow) {
      currentFlow = flow / 100;
      document.getElementById('flowValue').textContent = flow + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateHardness(hardness) {
      currentHardness = hardness / 100;
      document.getElementById('hardnessValue').textContent = hardness + '%';
      updateCurrentCanvas();
      updateBrushPreview();
    }

    function updateBrushPreview() {
      const preview = document.getElementById('brushPreview');
      
      // Enhanced preview sizing for tiny brushes
      let previewSize;
      if (currentSize < 1) {
        previewSize = Math.max(2, currentSize * 20); // Make tiny brushes visible in preview
      } else {
        previewSize = Math.max(3, currentSize / 4);
      }
      
      preview.style.width = previewSize + 'px';
      preview.style.height = previewSize + 'px';
      preview.style.backgroundColor = currentColor;
      preview.style.opacity = currentOpacity * currentFlow;
      
      // Apply brush type effects to preview
      switch (currentBrushType) {
        case 'soft':
          const blurAmount = currentSize < 1 ? Math.max(0.5, previewSize * 0.2) : Math.max(1, previewSize * 0.4 * (1 - currentHardness));
          preview.style.filter = `blur(${blurAmount}px)`;
          preview.style.boxShadow = `0 0 ${blurAmount * 3}px ${currentColor}`;
          break;
        case 'hard':
          preview.style.filter = 'none';
          preview.style.boxShadow = 'none';
          preview.style.borderRadius = currentSize < 1 ? '50%' : '3px';
          break;
        case 'texture':
          preview.style.filter = 'none';
          preview.style.boxShadow = `inset 0 0 ${previewSize}px rgba(0,0,0,0.4)`;
          preview.style.background = `linear-gradient(45deg, ${currentColor}, ${currentColor}dd)`;
          break;
        default:
          const softBlur = currentSize < 1 ? Math.max(0.2, previewSize * 0.1) : Math.max(0.5, previewSize * 0.15 * (1 - currentHardness));
          preview.style.filter = `blur(${softBlur}px)`;
          preview.style.boxShadow = `0 0 ${softBlur * 6}px ${currentColor}66`;
          preview.style.borderRadius = '50%';
      }
      
      // Special highlighting for tiny brushes
      if (currentSize < 1) {
        preview.style.border = '2px solid #00ff00';
        preview.style.animation = 'tinyGlow 2s ease-in-out infinite alternate';
      } else {
        preview.style.border = 'none';
        preview.style.animation = 'none';
      }
      
      updatePressureIndicator();
    }

    // Add tiny glow animation
    const tinyGlowStyle = document.createElement('style');
    tinyGlowStyle.textContent = `
      @keyframes tinyGlow {
        from { box-shadow: 0 0 5px #00ff00, inset 0 0 5px rgba(0, 255, 0, 0.2); }
        to { box-shadow: 0 0 15px #00ff00, inset 0 0 10px rgba(0, 255, 0, 0.4); }
      }
    `;
    document.head.appendChild(tinyGlowStyle);

    function updatePressureIndicator() {
      const pressureBar = document.getElementById('pressureBar');
      if (pressureBar) {
        pressureBar.style.width = (pressureSimulation * 100) + '%';
      }
    }

    function simulatePressureChange() {
      pressureSimulation = 0.4 + Math.random() * 0.6;
      updatePressureIndicator();
      
      if (currentTool === 'paintbrush' && canvases[currentLayerIndex]) {
        updateCurrentCanvas();
      }
    }

    setInterval(simulatePressureChange, 2500);

    // Layer functions
    function updateLayersPanel() {
      const panel = document.getElementById('layersPanel');
      panel.innerHTML = '';
      
      for (let i = canvases.length - 1; i >= 0; i--) {
        const layerItem = document.createElement('div');
        layerItem.className = `layer-item ${i === currentLayerIndex ? 'active' : ''}`;
        layerItem.onclick = () => setActiveLayer(i);
        
        layerItem.innerHTML = `
          <span>🎨 Layer ${i + 1}</span>
          <div class="layer-controls">
            <button class="layer-control-btn" onclick="event.stopPropagation(); toggleLayerVisibility(${i})" title="Toggle Visibility">👁️</button>
            ${i > 0 ? `<button class="layer-control-btn" onclick="event.stopPropagation(); deleteLayer(${i})" title="Delete Layer">🗑️</button>` : ''}
          </div>
        `;
        
        panel.appendChild(layerItem);
      }
    }

    function setActiveLayer(index) {
      canvases.forEach(canvas => {
        canvas.isDrawingMode = false;
      });
      
      currentLayerIndex = index;
      updateCurrentCanvas();
      updateLayersPanel();
      
      showToolMessage(`🎨 Switched to Layer ${index + 1}`);
    }

    function addLayer() {
      if (canvases.length >= MAX_LAYERS) {
        showToolMessage('📚 Maximum number of layers reached! Try combining some layers first.');
        return;
      }
      
      const newIndex = canvases.length;
      createLayer(newIndex);
      setActiveLayer(newIndex);
      updateLayersPanel();
      
      showToolMessage(`✨ New Layer ${newIndex + 1} created!`);
    }

    function deleteLayer(index) {
      if (canvases.length <= 1) {
        showToolMessage('🚫 Cannot delete the last layer! Create a new layer first.');
        return;
      }
      
      const canvasEl = document.getElementById(`canvas-${index}`);
      if (canvasEl) {
        canvasEl.remove();
      }
      
      canvases.splice(index, 1);
      
      for (let i = index; i < canvases.length; i++) {
        const canvas = canvases[i];
        canvas.lowerCanvasEl.id = `canvas-${i}`;
        canvas.lowerCanvasEl.style.zIndex = i;
      }
      
      if (currentLayerIndex >= index) {
        currentLayerIndex = Math.max(0, currentLayerIndex - 1);
      }
      
      setActiveLayer(currentLayerIndex);
      updateLayersPanel();
      
      showToolMessage('🗑️ Layer deleted successfully!');
    }

    function toggleLayerVisibility(index) {
      const canvas = canvases[index];
      if (canvas) {
        const isVisible = canvas.lowerCanvasEl.style.display !== 'none';
        canvas.lowerCanvasEl.style.display = isVisible ? 'none' : 'block';
        canvas.upperCanvasEl.style.display = isVisible ? 'none' : 'block';
        
        showToolMessage(isVisible ? '👁️‍🗨️ Layer hidden' : '👁️ Layer visible');
      }
    }

    // Enhanced Zoom functions with tiny brush considerations
    function zoomIn() {
      zoomLevel = Math.min(zoomLevel * 1.25, 16.0); // Increased max zoom for tiny brushes
      updateZoom();
      showToolMessage(`🔍 Zoomed in to ${Math.round(zoomLevel * 100)}%`);
    }

    function zoomOut() {
      zoomLevel = Math.max(zoomLevel / 1.25, 0.1);
      updateZoom();
      showToolMessage(`🔍 Zoomed out to ${Math.round(zoomLevel * 100)}%`);
    }

    function updateZoom() {
      document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
      canvases.forEach(canvas => {
        resizeCanvas(canvas);
      });
    }

    // Enhanced Undo/Redo system
    function saveState() {
      const activeCanvas = canvases[currentLayerIndex];
      if (activeCanvas) {
        undoStack.push({
          layerIndex: currentLayerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        if (undoStack.length > 100) {
          undoStack.shift();
        }
        
        redoStack = [];
      }
    }

    function undoAction() {
      if (undoStack.length === 0) {
        showToolMessage('🚫 Nothing to undo!');
        return;
      }
      
      const currentState = undoStack.pop();
      const activeCanvas = canvases[currentState.layerIndex];
      
      if (activeCanvas) {
        redoStack.push({
          layerIndex: currentState.layerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        activeCanvas.loadFromJSON(currentState.state, () => {
          activeCanvas.renderAll();
        });
        
        showToolMessage('↶ Undid last action');
      }
    }

    function redoAction() {
      if (redoStack.length === 0) {
        showToolMessage('🚫 Nothing to redo!');
        return;
      }
      
      const redoState = redoStack.pop();
      const activeCanvas = canvases[redoState.layerIndex];
      
      if (activeCanvas) {
        undoStack.push({
          layerIndex: redoState.layerIndex,
          state: JSON.stringify(activeCanvas.toJSON())
        });
        
        activeCanvas.loadFromJSON(redoState.state, () => {
          activeCanvas.renderAll();
        });
        
        showToolMessage('↷ Redid last action');
      }
    }

    function clearCurrentLayer() {
      if (confirm('🧼 Clear this layer? This action cannot be undone!')) {
        const activeCanvas = canvases[currentLayerIndex];
        if (activeCanvas) {
          saveState();
          activeCanvas.clear();
          if (currentLayerIndex === 0) {
            activeCanvas.backgroundColor = '#ffffff';
          }
          activeCanvas.renderAll();
          
          showToolMessage('🧼 Layer cleared successfully!');
        }
      }
    }
    
    function newProject() {
      if (confirm('🆕 Create a new canvas? Your current silly artwork will be lost!')) {
        undoStack = [];
        redoStack = [];
        
        canvases.forEach((canvas, index) => {
          canvas.clear();
          if (index === 0) {
            canvas.backgroundColor = '#ffffff';
          } else {
            canvas.backgroundColor = 'transparent';
          }
          canvas.renderAll();
        });
        
        currentLayerIndex = 0;
        zoomLevel = 1.0;
        updateZoom();
        updateLayersPanel();
        setActiveLayer(0);
        updateCurrentCanvas();
        
        showToolMessage('🆕 New canvas created! Start painting something silly! ✨');
      }
    }
    
    function saveProject() {
      try {
        const projectData = {
          version: '2.1',
          app: 'Silly Paintings Painting World',
          timestamp: new Date().toISOString(),
          layers: [],
          settings: {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            currentLayer: currentLayerIndex,
            zoom: zoomLevel,
            brushSettings: {
              size: currentSize,
              color: currentColor,
              opacity: currentOpacity,
              flow: currentFlow,
              hardness: currentHardness,
              type: currentBrushType,
              tool: currentTool
            }
          }
        };
        
        canvases.forEach((canvas, index) => {
          projectData.layers.push({
            index: index,
            data: canvas.toJSON(),
            visible: canvas.lowerCanvasEl.style.display !== 'none'
          });
        });
        
        const dataStr = JSON.stringify(projectData, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
        const exportFileDefaultName = `silly_painting_${timestamp}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showToolMessage('💾 Silly painting saved successfully!');
        
      } catch (error) {
        showToolMessage('❌ Error saving project: ' + error.message);
      }
    }
    
    function loadProject() {
      document.getElementById('fileInput').click();
    }
    
    function handleFileLoad(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const projectData = JSON.parse(e.target.result);
          
          if (!projectData.layers || !Array.isArray(projectData.layers)) {
            throw new Error('Invalid project file format');
          }
          
          // Clear existing canvases
          canvases.forEach(canvas => {
            const canvasEl = canvas.lowerCanvasEl;
            if (canvasEl && canvasEl.parentNode) {
              canvasEl.parentNode.removeChild(canvasEl);
            }
          });
          canvases = [];
          
          // Load project layers
          projectData.layers.forEach((layerData, index) => {
            createLayer(index);
            const canvas = canvases[index];
            
            canvas.loadFromJSON(layerData.data, () => {
              canvas.renderAll();
              
              if (layerData.visible === false) {
                canvas.lowerCanvasEl.style.display = 'none';
                canvas.upperCanvasEl.style.display = 'none';
              }
            });
          });
          
          // Restore settings
          currentLayerIndex = projectData.settings?.currentLayer || 0;
          if (currentLayerIndex >= canvases.length) {
            currentLayerIndex = 0;
          }
          
          if (projectData.settings?.zoom) {
            zoomLevel = projectData.settings.zoom;
            updateZoom();
          }
          
          // Restore brush settings if available
          if (projectData.settings?.brushSettings) {
            const brushSettings = projectData.settings.brushSettings;
            
            if (brushSettings.size !== undefined) {
              currentSize = brushSettings.size;
              document.getElementById('brushSize').value = currentSize;
              updateBrushSize(currentSize);
            }
            
            if (brushSettings.color) {
              selectColor(brushSettings.color);
            }
            
            if (brushSettings.opacity !== undefined) {
              currentOpacity = brushSettings.opacity;
              document.getElementById('brushOpacity').value = currentOpacity * 100;
              updateOpacity(currentOpacity * 100);
            }
            
            if (brushSettings.type) {
              setBrushType(brushSettings.type);
            }
            
            if (brushSettings.tool) {
              setTool(brushSettings.tool);
            }
          }
          
          setActiveLayer(currentLayerIndex);
          updateLayersPanel();
          
          event.target.value = '';
          
          showToolMessage('📂 Silly painting loaded successfully!');
          
        } catch (error) {
          showToolMessage('❌ Error loading project: ' + error.message);
        }
      };
      
      reader.readAsText(file);
    }
    
    function exportPNG() {
      try {
        const mergedCanvas = document.createElement('canvas');
        mergedCanvas.width = CANVAS_WIDTH;
        mergedCanvas.height = CANVAS_HEIGHT;
        const ctx = mergedCanvas.getContext('2d');
        
        // White background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        
        // Merge all visible layers
        canvases.forEach(canvas => {
          if (canvas.lowerCanvasEl.style.display !== 'none') {
            ctx.drawImage(canvas.lowerCanvasEl, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
          }
        });
        
        const image = mergedCanvas.toDataURL('image/png');
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().slice(0,19).replace(/:/g, '-');
        link.download = `silly_masterpiece_${timestamp}.png`;
        link.href = image;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showToolMessage('📷 Silly artwork exported successfully! 🎉');
        
      } catch (error) {
        showToolMessage('❌ Error exporting image: ' + error.message);
      }
    }

    // Enhanced touch support for mobile devices
    function addTouchSupport() {
      canvases.forEach(canvas => {
        const canvasEl = canvas.upperCanvasEl;
        
        // Prevent default touch behaviors
        canvasEl.addEventListener('touchstart', function(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
        
        canvasEl.addEventListener('touchmove', function(e) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
        
        canvasEl.addEventListener('touchend', function(e) {
          e.preventDefault();
          const mouseEvent = new MouseEvent('mouseup', {});
          canvasEl.dispatchEvent(mouseEvent);
        }, { passive: false });
      });
    }

    // Easter eggs and fun interactions
    function addEasterEggs() {
      let clickCount = 0;
      const logo = document.querySelector('.logo');
      
      logo.addEventListener('click', function() {
        clickCount++;
        if (clickCount === 5) {
          // Rainbow effect
          this.style.background = 'linear-gradient(45deg, #ff6b9d, #4ecdc4, #45b7d1, #96ceb4, #ffa500, #ff6b9d)';
          this.style.webkitBackgroundClip = 'text';
          this.style.webkitTextFillColor = 'transparent';
          this.style.backgroundSize = '400% 400%';
          this.style.animation = 'rainbow 2s ease-in-out infinite';
          
          // Add sparkle effect
          createSparkles();
          
          showToolMessage('🌈 You found the silly rainbow mode! Keep creating amazing silly art! ✨');
          
          setTimeout(() => {
            clickCount = 0;
            this.style.background = '';
            this.style.webkitBackgroundClip = '';
            this.style.webkitTextFillColor = '';
            this.style.backgroundSize = '';
            this.style.animation = '';
          }, 8000);
        } else if (clickCount === 3) {
          showToolMessage('🎯 Almost there! Click 2 more times for a silly surprise! ✨');
        }
      });
    }

    function createSparkles() {
      for (let i = 0; i < 20; i++) {
        setTimeout(() => {
          const sparkle = document.createElement('div');
          sparkle.textContent = '✨';
          sparkle.style.cssText = `
            position: fixed;
            font-size: ${Math.random() * 20 + 15}px;
            left: ${Math.random() * 100}vw;
            top: ${Math.random() * 100}vh;
            pointer-events: none;
            z-index: 10000;
            animation: sparkleFloat 3s ease-out forwards;
          `;
          
          const style = document.createElement('style');
          style.textContent = `
            @keyframes sparkleFloat {
              0% { opacity: 1; transform: translateY(0) rotate(0deg); }
              100% { opacity: 0; transform: translateY(-100px) rotate(360deg); }
            }
          `;
          document.head.appendChild(style);
          
          document.body.appendChild(sparkle);
          
          setTimeout(() => {
            if (document.body.contains(sparkle)) {
              document.body.removeChild(sparkle);
            }
          }, 3000);
        }, i * 100);
      }
    }

    // Rainbow animation keyframes
    const rainbowStyle = document.createElement('style');
    rainbowStyle.textContent = `
      @keyframes rainbow {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
    `;
    document.head.appendChild(rainbowStyle);

    // Initialize everything when page loads
    setTimeout(() => {
      addTouchSupport();
      addEasterEggs();
    }, 2500);

    // Auto-save functionality (in memory)
    let autoSaveData = null;
    function autoSave() {
      try {
        const projectData = {
          version: '2.1',
          app: 'Silly Paintings Painting World',
          timestamp: new Date().toISOString(),
          layers: [],
          settings: {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            currentLayer: currentLayerIndex,
            zoom: zoomLevel,
            brushSettings: {
              size: currentSize,
              color: currentColor,
              opacity: currentOpacity,
              flow: currentFlow,
              hardness: currentHardness,
              type: currentBrushType,
              tool: currentTool
            }
          }
